#!/bin/bash

# TV Sample Generator Script
# Generates realistic Japanese terrestrial TV broadcast sample data

set -euo pipefail

# ============================================================================
# TRAP HANDLERS FOR CLEANUP
# ============================================================================

# Cleanup function for trap handlers
cleanup_on_exit() {
    local exit_code=$?
    
    if [[ $exit_code -ne 0 ]]; then
        log "${RED}Script interrupted or failed (exit code: $exit_code)${NC}"
    fi
    
    # Clean up temporary files if they exist
    if [[ -d "$TEMP_DIR" ]]; then
        if [[ "$DEBUG" == true ]]; then
            log "${YELLOW}Keeping temporary files in $TEMP_DIR (debug mode)${NC}"
        else
            log "${YELLOW}Cleaning up temporary files in $TEMP_DIR${NC}"
            rm -rf "$TEMP_DIR"
        fi
    fi
    
    # Kill any background ffmpeg processes
    if pgrep -f "ffmpeg.*$TEMP_DIR" > /dev/null 2>&1; then
        log "${YELLOW}Terminating background ffmpeg processes${NC}"
        pkill -f "ffmpeg.*$TEMP_DIR" 2>/dev/null || true
    fi
    
    if [[ $exit_code -ne 0 ]]; then
        if [[ "$DEBUG" == true ]]; then
            log "${RED}Generation failed. Temporary files kept in $TEMP_DIR for debugging.${NC}"
        else
            log "${RED}Generation failed. All temporary files have been cleaned up.${NC}"
        fi
    fi
    
    exit $exit_code
}

# Set up trap handlers
trap cleanup_on_exit EXIT INT TERM

# ============================================================================
# GLOBAL CONFIGURATION AND VARIABLES
# ============================================================================

# Default configuration
DEBUG=false
CONFIG_FILE="scene_1.conf"

# Default broadcast metadata (can be overridden in config file)
DEFAULT_SERVICE_ID=65024  # 0xFE00 - For technical testing
DEFAULT_TRANSPORT_STREAM_ID=$(( (RANDOM % 65535) + 1 ))
DEFAULT_ORIGINAL_NETWORK_ID=$(( (RANDOM % 65535) + 1 ))
DEFAULT_SERVICE_NAME="Sample CH"
DEFAULT_SERVICE_PROVIDER="FFmpeg"
DEFAULT_NETWORK_NAME="Generated by naa0yama"
DEFAULT_START_TIME="2024-12-31 15:00:00"

# Colors for output (initialized here for use in cleanup)
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Global variables (will be set later)
CONFIG_BASENAME=""
OUTPUT_DIR=""
TEMP_DIR=""
LOG_FILE=""
FINAL_OUTPUT=""

# Global arrays (loaded from config)
declare -A CONFIG
declare -a SEGMENTS

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

# Logging function
log() {
    echo -e "${1}" | tee -a "$LOG_FILE" 2>/dev/null || echo -e "${1}"
}

# Show TSDuck installation instructions with latest release info
show_tsduck_install_instructions() {
    log "${YELLOW}TSDuck Installation Instructions:${NC}"
    log ""
    
    # Try to get latest release info from GitHub API with proper User-Agent
    local latest_info
    local user_agent="TV-Sample-Generator/1.0 (https://github.com/user/tv-sample-generator)"
    
    if command -v curl >/dev/null 2>&1; then
        latest_info=$(curl -s -H "User-Agent: $user_agent" "https://api.github.com/repos/tsduck/tsduck/releases/latest" 2>/dev/null)
    elif command -v wget >/dev/null 2>&1; then
        latest_info=$(wget --user-agent="$user_agent" -qO- "https://api.github.com/repos/tsduck/tsduck/releases/latest" 2>/dev/null)
    fi
    
    if [[ -n "$latest_info" ]] && command -v grep >/dev/null 2>&1; then
        # Extract version and Ubuntu 24.04 deb file URL
        local version tag_name ubuntu24_url
        version=$(echo "$latest_info" | grep '"tag_name"' | head -1 | sed 's/.*"tag_name": *"\([^"]*\)".*/\1/')
        tag_name="$version"
        ubuntu24_url=$(echo "$latest_info" | grep '"browser_download_url"' | grep 'ubuntu24.*\.deb' | head -1 | sed 's/.*"browser_download_url": *"\([^"]*\)".*/\1/')
        
        if [[ -n "$version" ]] && [[ -n "$ubuntu24_url" ]]; then
            log "${GREEN}Latest Release: $version${NC}"
            log ""
            log "${BLUE}= Ubuntu 24.04 LTS:${NC}"
            log "wget \"$ubuntu24_url\""
            log "sudo apt --fix-broken install \"./$(basename "$ubuntu24_url")\""
            log ""
            log "${BLUE}= Other Ubuntu/Debian versions:${NC}"
            log "Check available packages at: https://github.com/tsduck/tsduck/releases/tag/$tag_name"
        else
            # API response malformed, use fallback
            show_tsduck_fallback_instructions
        fi
    else
        # API not available, use fallback
        show_tsduck_fallback_instructions
    fi
    
    log ""
    log "${BLUE}= Alternative installation methods:${NC}"
    log "- Use package manager if available for your distribution"
    log "- Build from source: https://github.com/tsduck/tsduck"
    log ""
    log "${YELLOW}Note: You can use --skip-eit to bypass TSDuck requirement${NC}"
}

# Show fallback TSDuck installation instructions
show_tsduck_fallback_instructions() {
    log "${BLUE}= Installation Instructions:${NC}"
    log "1. Visit the official download page:"
    log "   ${YELLOW}https://tsduck.io/download/tsduck/${NC}"
    log ""
    log "2. Download the appropriate package for your system:"
    log "   - Ubuntu/Debian: .deb packages"
    log "   - Red Hat/CentOS/Fedora: .rpm packages"
    log "   - Windows: .exe installer"
    log "   - macOS: .pkg installer"
    log ""
    log "3. Install the downloaded package:"
    log "   ${BLUE}For Ubuntu/Debian:${NC}"
    log "   sudo apt install ./tsduck_*.deb"
    log ""
    log "   ${BLUE}For Red Hat/CentOS/Fedora:${NC}"
    log "   sudo rpm -i tsduck-*.rpm"
    log ""
    log "4. Verify installation:"
    log "   tsp --version"
}

# Show comprehensive help
show_help() {
    cat << 'EOF'
================================================================================
TV Sample Generator - Japanese Terrestrial TV Broadcast Sample Data Creator
================================================================================

DESCRIPTION:
    Generates realistic Japanese terrestrial TV broadcast sample data in MPEG-TS
    format, including main program segments, commercial segments with Japanese
    broadcasting standards (15-second intervals), transparent logos, and proper
    audio levels following ARIB specifications.

USAGE:
    ./generate_tv_sample.sh [OPTIONS]

OPTIONS:
    --debug              Enable verbose debug output
    -c, --config FILE    Configuration file (default: scene_1.conf)
    -y, --yes           Skip confirmation prompt and start generation immediately
    --h264              Use H.264/MPEG-4 video codec instead of MPEG-2 for smaller file size
    --skip-eit          Skip EIT/SDT/TDT metadata injection (default: inject metadata with TSDuck)
    -h, --help          Show this comprehensive help message

EXAMPLES:
    # Generate using default configuration
    ./generate_tv_sample.sh

    # Generate with debug output enabled
    ./generate_tv_sample.sh --debug

    # Use custom configuration file
    ./generate_tv_sample.sh -c my_program.conf

    # Debug mode with custom config
    ./generate_tv_sample.sh --debug -c my_program.conf

CONFIGURATION:
    The script uses configuration files to define:
    - Program structure (main segments, CM segments, timing)
    - Technical specifications (resolution, bitrate, audio levels)
    - Japanese broadcasting standards compliance

    Example configuration files:
    - scene_1.conf          Full 30-minute program (25 segments)
    - tv_config_test.conf   Short test program (5 segments)

OUTPUT:
    The generated MPEG-TS file will be named based on the configuration:
    - scene_1.conf → output/dummy_JTV_scene_1.ts
    - my_program.conf → output/dummy_JTV_my_program.ts

TECHNICAL SPECIFICATIONS:
    - Video: MPEG-2, 1440x1080, 16:9 aspect, 29.97fps interlaced
    - Audio: AAC-LC, 48kHz, stereo, Japanese broadcast levels
    - Container: MPEG-TS with proper stream IDs
    - Standards: ARIB compliant for Japanese terrestrial broadcasting

FEATURES:
    ✓ Main program segments with transparent logos
    ✓ Commercial segments following 15-second Japanese standards
    ✓ Silent periods with color inversion around commercials
    ✓ Japanese audio level standards (-20dBFS for 0VU reference)
    ✓ Configurable program structure via CSV-like format
    ✓ Professional broadcast-quality output
    ✓ Automatic cleanup on interruption or failure

REQUIREMENTS:
    - ffmpeg (with MPEG-2 and AAC encoding support)
    - bc (for duration calculations)
    - Standard Unix tools (grep, awk, etc.)
    - TSDuck (for EIT metadata injection, use --skip-eit to disable): https://tsduck.io/download/tsduck/

INTERRUPT HANDLING:
    The script handles interruptions (Ctrl+C, SIGTERM) gracefully:
    - Terminates any running ffmpeg processes
    - Cleans up temporary files automatically
    - Provides clear status messages

FILES CREATED:
    - output/dummy_JTV_[config].ts      Final MPEG-TS output
    - output/generation_report.txt       Detailed generation report
    - output/segment_structure.csv       Segment timing data
    - tv_generation.log                  Generation log file
    - temp_segments/                     Temporary files (auto-cleaned)

For more information about configuration format and technical details,
see the configuration files and generated reports.

================================================================================
EOF
}

# ============================================================================
# ARGUMENT PARSING
# ============================================================================

# Parse command line arguments
SKIP_CONFIRMATION=false
USE_H264=false
INJECT_EIT=true
while [[ $# -gt 0 ]]; do
    case $1 in
        --debug)
            DEBUG=true
            shift
            ;;
        -c|--config)
            CONFIG_FILE="$2"
            shift 2
            ;;
        -y|--yes)
            SKIP_CONFIRMATION=true
            shift
            ;;
        --h264)
            USE_H264=true
            shift
            ;;
        --skip-eit)
            INJECT_EIT=false
            shift
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            echo "Usage: $0 [--debug] [-c|--config CONFIG_FILE] [-y|--yes] [--h264] [--skip-eit] [-h|--help] (default: scene_1.conf)"
            echo "Use $0 --help for detailed information."
            exit 1
            ;;
    esac
done

# ============================================================================
# INITIALIZATION
# ============================================================================

# Set up paths and directories
CONFIG_BASENAME=$(basename "$CONFIG_FILE" .conf)
OUTPUT_DIR="output/${CONFIG_BASENAME}"
TEMP_DIR="temp"
LOG_FILE="tv_generation.log"
# Output filename will be set after parsing H.264 option
FINAL_OUTPUT=""

# Initialize log file
: > "$LOG_FILE"

# ============================================================================
# CORE FUNCTIONS
# ============================================================================

# Load configuration
load_config() {
    log "${BLUE}Loading configuration from $CONFIG_FILE${NC}"
    
    if [[ ! -f "$CONFIG_FILE" ]]; then
        log "${RED}Error: Configuration file $CONFIG_FILE not found${NC}"
        exit 1
    fi
    
    # Load technical settings - simplified approach
    while IFS='=' read -r key value; do
        # Skip comments and empty lines
        [[ "$key" =~ ^# ]] && continue
        [[ -z "$key" ]] && continue
        
        if [[ -n "$key" ]] && [[ -n "$value" ]]; then
            CONFIG["$key"]="$value"
            # echo "Loaded: $key=$value" >&2
        fi
    done < <(grep '^[A-Z_0-9]*=' "$CONFIG_FILE")
    
    # Set broadcast metadata with defaults if not specified in config
    CONFIG["BROADCAST_SERVICE_ID"]="${CONFIG[BROADCAST_SERVICE_ID]:-$DEFAULT_SERVICE_ID}"
    CONFIG["BROADCAST_TRANSPORT_STREAM_ID"]="${CONFIG[BROADCAST_TRANSPORT_STREAM_ID]:-$DEFAULT_TRANSPORT_STREAM_ID}"
    CONFIG["BROADCAST_ORIGINAL_NETWORK_ID"]="${CONFIG[BROADCAST_ORIGINAL_NETWORK_ID]:-$DEFAULT_ORIGINAL_NETWORK_ID}"
    CONFIG["BROADCAST_SERVICE_NAME"]="${CONFIG[BROADCAST_SERVICE_NAME]:-$DEFAULT_SERVICE_NAME}"
    CONFIG["BROADCAST_SERVICE_PROVIDER"]="${CONFIG[BROADCAST_SERVICE_PROVIDER]:-$DEFAULT_SERVICE_PROVIDER}"
    CONFIG["BROADCAST_NETWORK_NAME"]="${CONFIG[BROADCAST_NETWORK_NAME]:-$DEFAULT_NETWORK_NAME}"
    CONFIG["BROADCAST_START_TIME"]="${CONFIG[BROADCAST_START_TIME]:-$DEFAULT_START_TIME}"
    
    # Load segment structure - now with START_FRAME,END_FRAME format
    local in_segments=false
    local prev_end_frame=-1
    local line_num=0
    while IFS=',' read -r type name start_frame end_frame; do
        line_num=$((line_num + 1))
        # Skip comments and empty lines
        [[ "$type" =~ ^# ]] && continue
        [[ -z "$type" ]] && continue
        
        if [[ "$type" == "SECTION_TYPE" ]]; then
            in_segments=true
            continue
        fi
        
        # Only process segment data, not config data
        if [[ $in_segments == true ]] && [[ "$type" =~ ^(RecMargin|Main|CM)$ ]] && [[ -n "$start_frame" ]] && [[ -n "$end_frame" ]]; then
            # Validate frame continuity - START must be previous END + 1
            if [[ $prev_end_frame -ge 0 ]] && [[ $start_frame -ne $((prev_end_frame + 1)) ]]; then
                log "${RED}Error: Frame continuity broken at line $line_num ($type,$name)${NC}"
                log "${RED}Previous END_FRAME=$prev_end_frame, current START_FRAME=$start_frame${NC}"
                log "${RED}Expected START_FRAME=$((prev_end_frame + 1)) (previous END + 1)${NC}"
                exit 1
            fi
            
            # Validate start < end (except for RecMargin which can have start == end)
            if [[ "$type" != "RecMargin" ]] && [[ $start_frame -ge $end_frame ]]; then
                log "${RED}Error: Invalid frame range at line $line_num: START_FRAME($start_frame) >= END_FRAME($end_frame)${NC}"
                exit 1
            fi
            
            SEGMENTS+=("$type,$name,$start_frame,$end_frame")
            prev_end_frame=$end_frame
            # echo "DEBUG: Added segment: $type,$name,$start_frame,$end_frame" >&2
        fi
    done < "$CONFIG_FILE"
    
    log "${GREEN}Loaded ${#SEGMENTS[@]} segments and ${#CONFIG[@]} configuration parameters${NC}"
    
    # Calculate total duration from segments for metadata generation
    local max_end_frame=0
    for segment_data in "${SEGMENTS[@]}"; do
        IFS=',' read -r type name start_frame end_frame <<< "$segment_data"
        [[ "$type" == "RecMargin" ]] && continue
        if [[ $end_frame -gt $max_end_frame ]]; then
            max_end_frame=$end_frame
        fi
    done
    CONFIG["BROADCAST_DURATION_FRAMES"]=$max_end_frame
    local duration_seconds
    duration_seconds=$(calculate_duration 0 "$max_end_frame")
    CONFIG["BROADCAST_DURATION_SECONDS"]="$duration_seconds"
    
    # Override codec settings if --h264 option is used
    if [[ "$USE_H264" == true ]]; then
        log "${BLUE}Switching to H.264/MPEG-4 video codec for smaller file size${NC}"
        
        # Calculate optimal H.264 bitrate (roughly 60% of MPEG-2 for same quality)
        local mpeg2_bitrate="${CONFIG[VIDEO_BITRATE]}"
        local mpeg2_value
        mpeg2_value="${mpeg2_bitrate//[!0-9.]/}"
        local mpeg2_unit
        mpeg2_unit="${mpeg2_bitrate//[0-9.]/}"
        
        local h264_value
        h264_value=$(echo "scale=1; $mpeg2_value * 0.6" | bc -l)
        local h264_bitrate="${h264_value}${mpeg2_unit}"
        
        # Calculate maxrate (1.5x bitrate) 
        local h264_maxrate_value
        h264_maxrate_value=$(echo "scale=1; $h264_value * 1.5" | bc -l)
        local h264_maxrate="${h264_maxrate_value}${mpeg2_unit}"
        
        local reduction_percent
        reduction_percent=$(echo "scale=1; (1 - 0.6) * 100" | bc -l)
        log "${GREEN}H.264 optimized bitrate: $mpeg2_bitrate → $h264_bitrate (${reduction_percent}% reduction)${NC}"
        
        CONFIG["VIDEO_CODEC"]="libx264"
        CONFIG["VIDEO_PROFILE"]="high"
        CONFIG["VIDEO_LEVEL"]="4.1"
        CONFIG["VIDEO_BITRATE"]="$h264_bitrate"
        CONFIG["VIDEO_MAXRATE"]="$h264_maxrate"
        CONFIG["VIDEO_BUFSIZE"]="16M"
        # Add H.264 specific parameters
        CONFIG["H264_PRESET"]="medium"
        CONFIG["H264_CRF"]="23"  # Slightly higher CRF for better efficiency
    fi
    
    # Set final output filename based on codec choice
    if [[ "$USE_H264" == true ]]; then
        FINAL_OUTPUT="dummy_JTV_${CONFIG_BASENAME}_h264.ts"
    else
        FINAL_OUTPUT="dummy_JTV_${CONFIG_BASENAME}.ts"
    fi
}

# Calculate frame duration from frame numbers
calculate_duration() {
    local start_frame=$1
    local end_frame=$2
    local fps_num=30000
    local fps_den=1001
    
    local frame_count=$((end_frame - start_frame))
    local duration
    duration=$(echo "scale=6; $frame_count * $fps_den / $fps_num" | bc -l)
    echo "$duration"
}

# Format duration in seconds to HH:MM:SS.mmm format
format_duration() {
    local duration_seconds=$1
    local hours minutes seconds milliseconds
    
    # Convert to integer calculations to avoid printf issues
    local total_ms_str
    total_ms_str=$(echo "scale=0; $duration_seconds * 1000 / 1" | bc -l)
    # Ensure it's an integer by removing any decimal point
    local total_ms=${total_ms_str%.*}
    
    hours=$((total_ms / 3600000))
    local remaining_ms=$((total_ms - hours * 3600000))
    
    minutes=$((remaining_ms / 60000))
    remaining_ms=$((remaining_ms - minutes * 60000))
    
    seconds=$((remaining_ms / 1000))
    milliseconds=$((remaining_ms % 1000))
    
    printf "%02dh %02dm %02d.%03ds" "$hours" "$minutes" "$seconds" "$milliseconds"
}

# Show media specifications summary
show_media_specs() {
    local duration_formatted
    duration_formatted=$(printf "%02d:%02d:%02d" $((${CONFIG[BROADCAST_DURATION_SECONDS]%.*}/3600)) $(((${CONFIG[BROADCAST_DURATION_SECONDS]%.*}%3600)/60)) $((${CONFIG[BROADCAST_DURATION_SECONDS]%.*}%60)))
    
    # Video codec display name
    local video_codec_name
    case "${CONFIG[VIDEO_CODEC]}" in
        "mpeg2video") video_codec_name="MPEG-2" ;;
        "libx264") video_codec_name="H.264/MPEG-4 AVC" ;;
        *) video_codec_name="${CONFIG[VIDEO_CODEC]}" ;;
    esac
    
    # Audio codec display name  
    local audio_codec_name
    case "${CONFIG[AUDIO_CODEC]}" in
        "aac") audio_codec_name="MPEG-2 AAC LC" ;;
        "mp2") audio_codec_name="MPEG-1 Layer II" ;;
        *) audio_codec_name="${CONFIG[AUDIO_CODEC]}" ;;
    esac
    
    # Audio channels display
    local audio_channels_text
    case "${CONFIG[AUDIO_CHANNELS]}" in
        "1") audio_channels_text="mono" ;;
        "2") audio_channels_text="stereo" ;;
        *) audio_channels_text="${CONFIG[AUDIO_CHANNELS]}ch" ;;
    esac
    
    # Video format description
    local video_format="progressive"
    if [[ "${CONFIG[VIDEO_CODEC]}" == "mpeg2video" ]]; then
        video_format="interlaced"
    fi
    
    log "${GREEN}Video:${NC}         $video_codec_name, $video_format, ${CONFIG[VIDEO_WIDTH]}x${CONFIG[VIDEO_HEIGHT]} [SAR 4:3, DAR ${CONFIG[VIDEO_ASPECT]}]"
    log "               ${CONFIG[FRAME_RATE]} fps, bitrate ${CONFIG[VIDEO_BITRATE]}, maxrate ${CONFIG[VIDEO_MAXRATE]}"
    log "${GREEN}Audio:${NC}         $audio_codec_name, ${CONFIG[AUDIO_SAMPLE_RATE]}Hz, $audio_channels_text, ${CONFIG[AUDIO_BITRATE]}"
    log "${GREEN}Duration:${NC}      $duration_formatted (${CONFIG[BROADCAST_DURATION_FRAMES]} frames)"
    log "${GREEN}Broadcast:${NC}     Service ID ${CONFIG[BROADCAST_SERVICE_ID]}, Transport Stream ID ${CONFIG[BROADCAST_TRANSPORT_STREAM_ID]}"
    log "               Service: \"${CONFIG[BROADCAST_SERVICE_NAME]}\" by \"${CONFIG[BROADCAST_SERVICE_PROVIDER]}\""
    log "               Network: \"${CONFIG[BROADCAST_NETWORK_NAME]}\""
    
    if [[ "$INJECT_EIT" == true ]]; then
        log "${GREEN}EIT Metadata:${NC}  Start time ${CONFIG[BROADCAST_START_TIME]}, Present/Following enabled"
    else
        log "${YELLOW}EIT Metadata:${NC} Disabled (--skip-eit specified)"
    fi
}

# Convert frame number to HH:MM:SS.FF format
frame_to_timecode() {
    local frame=$1
    local fps_num=30000
    local fps_den=1001
    local fps
    fps=$(echo "scale=6; $fps_num / $fps_den" | bc -l)
    
    # Calculate total seconds
    local total_seconds
    total_seconds=$(echo "scale=6; $frame * $fps_den / $fps_num" | bc -l)
    
    # Extract hours, minutes, seconds, and frame
    local hours
    hours=$(echo "$total_seconds / 3600" | bc)
    local remaining
    remaining=$(echo "scale=6; $total_seconds - $hours * 3600" | bc -l)
    local minutes
    minutes=$(echo "$remaining / 60" | bc)
    local seconds
    seconds=$(echo "scale=6; $remaining - $minutes * 60" | bc -l)
    
    # Calculate frame within the second
    local frame_in_second
    frame_in_second=$(echo "scale=0; ($seconds - ($seconds / 1 * 1)) * $fps" | bc -l)
    local whole_seconds
    whole_seconds=$(echo "scale=0; $seconds / 1" | bc)
    
    printf "%02d:%02d:%02d.%02.0f" "$hours" "$minutes" "$whole_seconds" "$frame_in_second"
}

# Preview segment information and get confirmation
preview_segments() {
    log "${BLUE}=== Media Configuration Preview ===${NC}"
    log "${GREEN}Configuration:${NC} $CONFIG_FILE"
    log "${GREEN}Output:${NC}        $OUTPUT_DIR/$FINAL_OUTPUT"
    log ""
    
    # Display media specifications
    show_media_specs
    log ""
    
    log "${BLUE}=== Segment Structure Preview ===${NC}"
    
    # Table header as requested by user
    printf "%-15s %-20s %-12s %-12s %-25s\n" "SECTION_TYPE" "SECTION_NAME" "START_FRAME" "END_FRAME" "TIMESTAMP"
    printf "%-15s %-20s %-12s %-12s %-25s\n" "============" "============" "===========" "=========" "======================="
    
    for segment_data in "${SEGMENTS[@]}"; do
        IFS=',' read -r type name start_frame end_frame <<< "$segment_data"
        
        # Skip RecMargin segments for display (but keep them in processing)
        if [[ "$type" == "RecMargin" ]]; then
            continue
        fi
        
        local start_timecode
        start_timecode=$(frame_to_timecode "$start_frame")
        local end_timecode
        end_timecode=$(frame_to_timecode "$end_frame")
        
        # Calculate duration for this segment
        local duration
        duration=$(calculate_duration "$start_frame" "$end_frame")
        # Format duration with decimal point alignment (supports up to 9999.999)
        local formatted_duration
        formatted_duration=$(printf "%7.3f" "$duration")
        
        printf "%-15s %-20s %-12s %-12s %-25s\n" "$type" "$name" "$start_frame" "$end_frame" "$start_timecode - $end_timecode (${formatted_duration}s)"
    done
    
    log ""
    
    if [[ "$SKIP_CONFIRMATION" == true ]]; then
        log "${GREEN}Auto-confirmed with -y option. Starting generation...${NC}"
        return 0
    fi
    
    echo -n -e "${YELLOW}Start generation? (y/N): ${NC}"
    read -r response
    case "$response" in
        [yY]|[yY][eE][sS])
            log "${GREEN}Starting generation...${NC}"
            return 0
            ;;
        *)
            log "${YELLOW}Generation cancelled by user${NC}"
            exit 0
            ;;
    esac
}

# Generate main program segment
generate_main_segment() {
    local segment_name=$1
    local duration=$2
    local output_file=$3
    
    # Main segment generation (log handled by caller)
    
    # Create logo overlay (simple text as transparent logo)
    local logo_text="TV-LOGO"
    
    # Build H.264 specific parameters if needed
    local h264_params=()
    if [[ "$USE_H264" == true ]]; then
        h264_params=(-preset "${CONFIG[H264_PRESET]}" -crf "${CONFIG[H264_CRF]}" -x264opts keyint=60:min-keyint=1)
    fi
    
    ffmpeg -y \
        -f lavfi -i "testsrc2=size=${CONFIG[VIDEO_WIDTH]}x${CONFIG[VIDEO_HEIGHT]}:rate=${CONFIG[FRAME_RATE]}:duration=$duration" \
        -f lavfi -i "sine=frequency=1000:sample_rate=${CONFIG[AUDIO_SAMPLE_RATE]}:duration=$duration,aformat=channel_layouts=stereo" \
        -filter_complex "
            [0:v]drawtext=fontsize=60:fontcolor=white:text='$segment_name':x=(w-text_w)/2:y=(h-text_h)/2-80:box=1:boxcolor=black@0.7:boxborderw=10,drawtext=fontsize=35:fontcolor=yellow:text='TIMECODE\: %{pts\:hms}':x=(w-text_w)/2:y=(h-text_h)/2+40:box=1:boxcolor=black@0.7:boxborderw=10,drawtext=fontsize=30:fontcolor=white@${CONFIG[MAIN_LOGO_OPACITY]}:text='$logo_text':x=w-text_w-50:y=50[v];
            [1:a]volume=${CONFIG[AUDIO_LEVEL_0VU]:-"-20"}dB[a]
        " \
        -map "[v]" -map "[a]" \
        -c:v "${CONFIG[VIDEO_CODEC]}" -profile:v "${CONFIG[VIDEO_PROFILE]}" -level "${CONFIG[VIDEO_LEVEL]}" \
        -bf 2 -b_strategy 1 -sc_threshold 40 -qcomp 0.6 \
        -max_muxing_queue_size 1024 \
        -s "${CONFIG[VIDEO_WIDTH]}x${CONFIG[VIDEO_HEIGHT]}" -aspect "${CONFIG[VIDEO_ASPECT]}" \
        -r "${CONFIG[FRAME_RATE]}" -field_order tt -flags +ildct+ilme -top 1 -pix_fmt yuv420p \
        -colorspace bt709 -color_trc bt709 -color_primaries bt709 \
        -b:v "${CONFIG[VIDEO_BITRATE]}" -maxrate "${CONFIG[VIDEO_MAXRATE]}" -bufsize "${CONFIG[VIDEO_BUFSIZE]}" \
        ${h264_params:+"${h264_params[@]}"} \
        -c:a "${CONFIG[AUDIO_CODEC]}" -profile:a "${CONFIG[AUDIO_PROFILE]}" \
        -b:a "${CONFIG[AUDIO_BITRATE]}" -ar "${CONFIG[AUDIO_SAMPLE_RATE]}" -ac "${CONFIG[AUDIO_CHANNELS]}" \
        "$output_file" 2>> "$LOG_FILE"
}

# Generate CM segment with silence padding and color inversion
generate_cm_segment() {
    local segment_name=$1
    local duration=$2
    local output_file=$3
    
    # CM segment generation (log handled by caller)
    
    local silence_dur=${CONFIG[CM_SILENCE_DURATION]}
    local content_dur
    content_dur=$(echo "scale=6; $duration - 2 * $silence_dur" | bc -l)
    
    # Generate CM content (solid color with CM name)
    local cm_number
    cm_number=$(echo "$segment_name" | grep -o '[0-9]\+-[0-9]\+' | head -1)
    [[ -z "$cm_number" ]] && cm_number="1-1"  # fallback
    
    # Color selection for CM content
    local colors=("red" "blue" "green" "yellow" "magenta" "cyan")
    local color_hash
    color_hash=$(echo "$segment_name" | md5sum | head -c 2)
    local color_index=$(( (0x$color_hash) % ${#colors[@]}))
    local color="${colors[$color_index]}"
    
    # Build H.264 specific parameters if needed
    local h264_params=()
    if [[ "$USE_H264" == true ]]; then
        h264_params=(-preset "${CONFIG[H264_PRESET]}" -crf "${CONFIG[H264_CRF]}" -x264opts keyint=60:min-keyint=1)
    fi
    
    # Enhanced CM generation with silence padding and color inversion
    # For short durations, simplify to single segment
    local duration_check
    duration_check=$(echo "$duration < 5.0" | bc -l)
    if (( duration_check )); then
        # Short CM - single segment with audio
        ffmpeg -y \
            -f lavfi -i "color=$color:size=${CONFIG[VIDEO_WIDTH]}x${CONFIG[VIDEO_HEIGHT]}:rate=${CONFIG[FRAME_RATE]}:duration=$duration" \
            -f lavfi -i "sine=frequency=800:sample_rate=${CONFIG[AUDIO_SAMPLE_RATE]}:duration=$duration,aformat=channel_layouts=stereo" \
            -filter_complex "
                [0:v]drawtext=fontsize=100:fontcolor=white:text='CM $cm_number':x=(w-text_w)/2:y=(h-text_h)/2[v];
                [1:a]volume=${CONFIG[AUDIO_LEVEL_0VU]:-"-20"}dB[a]
            " \
            -map "[v]" -map "[a]" \
            -c:v "${CONFIG[VIDEO_CODEC]}" -profile:v "${CONFIG[VIDEO_PROFILE]}" -level "${CONFIG[VIDEO_LEVEL]}" \
        -bf 2 -b_strategy 1 -sc_threshold 40 -qcomp 0.6 \
        -max_muxing_queue_size 1024 \
            -s "${CONFIG[VIDEO_WIDTH]}x${CONFIG[VIDEO_HEIGHT]}" -aspect "${CONFIG[VIDEO_ASPECT]}" \
            -r "${CONFIG[FRAME_RATE]}" -field_order tt -flags +ildct+ilme -top 1 -pix_fmt yuv420p \
            -colorspace bt709 -color_trc bt709 -color_primaries bt709 \
            -b:v "${CONFIG[VIDEO_BITRATE]}" -maxrate "${CONFIG[VIDEO_MAXRATE]}" -bufsize "${CONFIG[VIDEO_BUFSIZE]}" \
            ${h264_params:+"${h264_params[@]}"} \
            -c:a "${CONFIG[AUDIO_CODEC]}" -profile:a "${CONFIG[AUDIO_PROFILE]}" \
            -b:a "${CONFIG[AUDIO_BITRATE]}" -ar "${CONFIG[AUDIO_SAMPLE_RATE]}" -ac "${CONFIG[AUDIO_CHANNELS]}" \
            "$output_file" 2>> "$LOG_FILE"
    else
        # Long CM - with silence padding and color inversion
        # Structure: silence(inverted) -> content(normal) -> silence(inverted)
        local temp_content="${output_file%.mp4}_content.mp4"
        local temp_silence="${output_file%.mp4}_silence.mp4"
        
        # Generate content segment
        ffmpeg -y \
            -f lavfi -i "color=$color:size=${CONFIG[VIDEO_WIDTH]}x${CONFIG[VIDEO_HEIGHT]}:rate=${CONFIG[FRAME_RATE]}:duration=$content_dur" \
            -f lavfi -i "sine=frequency=800:sample_rate=${CONFIG[AUDIO_SAMPLE_RATE]}:duration=$content_dur,aformat=channel_layouts=stereo" \
            -filter_complex "
                [0:v]drawtext=fontsize=100:fontcolor=white:text='CM $cm_number':x=(w-text_w)/2:y=(h-text_h)/2[v];
                [1:a]volume=${CONFIG[AUDIO_LEVEL_0VU]:-"-20"}dB[a]
            " \
            -map "[v]" -map "[a]" \
            -c:v "${CONFIG[VIDEO_CODEC]}" -profile:v "${CONFIG[VIDEO_PROFILE]}" -level "${CONFIG[VIDEO_LEVEL]}" \
        -bf 2 -b_strategy 1 -sc_threshold 40 -qcomp 0.6 \
        -max_muxing_queue_size 1024 \
            -s "${CONFIG[VIDEO_WIDTH]}x${CONFIG[VIDEO_HEIGHT]}" -aspect "${CONFIG[VIDEO_ASPECT]}" \
            -r "${CONFIG[FRAME_RATE]}" -field_order tt -flags +ildct+ilme -top 1 -pix_fmt yuv420p \
            -colorspace bt709 -color_trc bt709 -color_primaries bt709 \
            -b:v "${CONFIG[VIDEO_BITRATE]}" -maxrate "${CONFIG[VIDEO_MAXRATE]}" -bufsize "${CONFIG[VIDEO_BUFSIZE]}" \
            ${h264_params:+"${h264_params[@]}"} \
            -c:a "${CONFIG[AUDIO_CODEC]}" -profile:a "${CONFIG[AUDIO_PROFILE]}" \
            -b:a "${CONFIG[AUDIO_BITRATE]}" -ar "${CONFIG[AUDIO_SAMPLE_RATE]}" -ac "${CONFIG[AUDIO_CHANNELS]}" \
            "$temp_content" 2>> "$LOG_FILE"
        
        # Generate silence segment (inverted color)
        ffmpeg -y \
            -f lavfi -i "color=$color:size=${CONFIG[VIDEO_WIDTH]}x${CONFIG[VIDEO_HEIGHT]}:rate=${CONFIG[FRAME_RATE]}:duration=$silence_dur" \
            -f lavfi -i "anullsrc=channel_layout=stereo:sample_rate=${CONFIG[AUDIO_SAMPLE_RATE]}:duration=$silence_dur" \
            -filter_complex "
                [0:v]negate,drawtext=fontsize=80:fontcolor=black:text='SILENCE':x=(w-text_w)/2:y=(h-text_h)/2[v];
                [1:a]volume=${CONFIG[AUDIO_SILENCE_THRESHOLD]:-"-70"}dB[a]
            " \
            -map "[v]" -map "[a]" \
            -c:v "${CONFIG[VIDEO_CODEC]}" -profile:v "${CONFIG[VIDEO_PROFILE]}" -level "${CONFIG[VIDEO_LEVEL]}" \
        -bf 2 -b_strategy 1 -sc_threshold 40 -qcomp 0.6 \
        -max_muxing_queue_size 1024 \
            -s "${CONFIG[VIDEO_WIDTH]}x${CONFIG[VIDEO_HEIGHT]}" -aspect "${CONFIG[VIDEO_ASPECT]}" \
            -r "${CONFIG[FRAME_RATE]}" -field_order tt -flags +ildct+ilme -top 1 -pix_fmt yuv420p \
            -colorspace bt709 -color_trc bt709 -color_primaries bt709 \
            -b:v "${CONFIG[VIDEO_BITRATE]}" -maxrate "${CONFIG[VIDEO_MAXRATE]}" -bufsize "${CONFIG[VIDEO_BUFSIZE]}" \
            ${h264_params:+"${h264_params[@]}"} \
            -c:a "${CONFIG[AUDIO_CODEC]}" -profile:a "${CONFIG[AUDIO_PROFILE]}" \
            -b:a "${CONFIG[AUDIO_BITRATE]}" -ar "${CONFIG[AUDIO_SAMPLE_RATE]}" -ac "${CONFIG[AUDIO_CHANNELS]}" \
            "$temp_silence" 2>> "$LOG_FILE"
        
        # Create concat list and combine
        echo "file '$(basename "$temp_silence")'" > "${output_file%.mp4}_list.txt"
        echo "file '$(basename "$temp_content")'" >> "${output_file%.mp4}_list.txt"
        echo "file '$(basename "$temp_silence")'" >> "${output_file%.mp4}_list.txt"
        
        # Concatenate segments
        ffmpeg -y -f concat -safe 0 -i "${output_file%.mp4}_list.txt" \
            -c:v "${CONFIG[VIDEO_CODEC]}" -profile:v "${CONFIG[VIDEO_PROFILE]}" -level "${CONFIG[VIDEO_LEVEL]}" \
        -bf 2 -b_strategy 1 -sc_threshold 40 -qcomp 0.6 \
        -max_muxing_queue_size 1024 \
            -s "${CONFIG[VIDEO_WIDTH]}x${CONFIG[VIDEO_HEIGHT]}" -aspect "${CONFIG[VIDEO_ASPECT]}" \
            -r "${CONFIG[FRAME_RATE]}" -field_order tt -flags +ildct+ilme -top 1 -pix_fmt yuv420p \
            -colorspace bt709 -color_trc bt709 -color_primaries bt709 \
            -b:v "${CONFIG[VIDEO_BITRATE]}" -maxrate "${CONFIG[VIDEO_MAXRATE]}" -bufsize "${CONFIG[VIDEO_BUFSIZE]}" \
            -c:a "${CONFIG[AUDIO_CODEC]}" -profile:a "${CONFIG[AUDIO_PROFILE]}" \
            -b:a "${CONFIG[AUDIO_BITRATE]}" -ar "${CONFIG[AUDIO_SAMPLE_RATE]}" -ac "${CONFIG[AUDIO_CHANNELS]}" \
            "$output_file" 2>> "$LOG_FILE"
        
        # Cleanup temporary files
        rm -f "$temp_content" "$temp_silence" "${output_file%.mp4}_list.txt"
    fi
}

# Generate all segments
generate_segments() {
    log "${BLUE}Generating individual segments${NC}"
    
    mkdir -p "$TEMP_DIR"
    
    local segment_count=0
    # Count total segments (excluding RecMargin)
    local total_segments=0
    for segment_data in "${SEGMENTS[@]}"; do
        IFS=',' read -r type name start_frame end_frame <<< "$segment_data"
        if [[ "$type" != "RecMargin" ]]; then
            total_segments=$((total_segments + 1))
        fi
    done
    
    log "${BLUE}Processing $total_segments segments${NC}"
    
    for segment_data in "${SEGMENTS[@]}"; do
        IFS=',' read -r type name start_frame end_frame <<< "$segment_data"
        
        [[ "$DEBUG" == true ]] && log "${YELLOW}Processing segment: $type,$name,$start_frame,$end_frame${NC}"
        
        # Skip RecMargin segments
        if [[ "$type" == "RecMargin" ]]; then
            # log "${YELLOW}Skipping RecMargin segment${NC}"
            continue
        fi
        
        local frame_duration=$((end_frame - start_frame + 1))
        local time_duration
        time_duration=$(calculate_duration "$start_frame" $((end_frame + 1)))
        local output_file
        output_file="$TEMP_DIR/segment_$(printf "%03d" "$segment_count")_${name}.mp4"
        
        # Calculate progress percentage with precision
        local progress
        local current_segment=$((segment_count + 1))
        progress=$(echo "scale=2; $current_segment * 100 / $total_segments" | bc -l)
        
        local formatted_duration
        formatted_duration=$(format_duration "$time_duration")
        log "${GREEN}Segment $(printf "%03d" $((segment_count + 1)))/$(printf "%03d" $total_segments) ($(printf "%06.2f" "$progress")%)  : $(printf "%-32s" "$name") ($(printf "%6d" $frame_duration) frames, $formatted_duration)${NC}"
        
        case "$type" in
            "Main")
                local formatted_sub_duration
                formatted_sub_duration=$(format_duration "$time_duration")
                log "${YELLOW}  → Generating main segment: $(printf "%-32s" "$name") ($(printf "%15s" "")$formatted_sub_duration)${NC}"
                generate_main_segment "$name" "$time_duration" "$output_file" || {
                    log "${RED}Error generating main segment $name${NC}"
                    exit 1
                }
                ;;
            "CM")
                local formatted_sub_duration
                formatted_sub_duration=$(format_duration "$time_duration")
                log "${YELLOW}  → Generating CM segment: $(printf "%-32s" "$name") ($(printf "%15s" "")$formatted_sub_duration)${NC}"
                generate_cm_segment "$name" "$time_duration" "$output_file" || {
                    log "${RED}Error generating CM segment $name${NC}"
                    exit 1
                }
                ;;
        esac
        
        log "${GREEN}  ✓ Completed: $name${NC}"
        segment_count=$((segment_count + 1))
        [[ "$DEBUG" == true ]] && log "${BLUE}Moving to next segment (current count: $segment_count)${NC}"
    done
    
    log "${GREEN}Generated $segment_count segments${NC}"
}

# Concatenate all segments
concatenate_segments() {
    log "${BLUE}Concatenating segments to intermediate output${NC}"
    
    # Create concat list
    local concat_file="$TEMP_DIR/concat_list.txt"
    : > "$concat_file"
    
    for file in "$TEMP_DIR"/segment_*.mp4; do
        if [[ -f "$file" ]]; then
            echo "file '../$file'" >> "$concat_file"
        fi
    done
    
    # Build H.264 specific parameters if needed
    local h264_params=()
    if [[ "$USE_H264" == true ]]; then
        h264_params=(-preset "${CONFIG[H264_PRESET]}" -crf "${CONFIG[H264_CRF]}" -x264opts keyint=60:min-keyint=1)
    fi
    
    # Concatenate and convert to MPEG-TS
    ffmpeg -y \
        -f concat -safe 0 -i "$concat_file" \
        -c:v mpeg2video -b:v 8M \
        -c:a aac -b:a 256k -ar 48000 -ac 2 \
        -strict experimental \
        -mpegts_service_id "${CONFIG[BROADCAST_SERVICE_ID]}" \
        -mpegts_transport_stream_id "${CONFIG[BROADCAST_TRANSPORT_STREAM_ID]}" \
        -metadata service_provider="${CONFIG[BROADCAST_SERVICE_PROVIDER]}" \
        -metadata service_name="${CONFIG[BROADCAST_SERVICE_NAME]}" \
        -mpegts_pmt_start_pid 257 \
        -mpegts_start_pid 273 \
        -muxrate 15M \
        -mpegts_flags +initial_discontinuity \
        -f mpegts \
        "$TEMP_DIR/$FINAL_OUTPUT" 2>> "$LOG_FILE"
    
    log "${GREEN}Intermediate output created: $TEMP_DIR/$FINAL_OUTPUT${NC}"
}

# Generate optimized broadcast metadata files (based on generate_standalone_ts.sh)
generate_metadata_files() {
    log "${BLUE}Generating comprehensive PSI/SI tables using generate_standalone_ts.sh approach${NC}"
    
    mkdir -p "$OUTPUT_DIR"
    mkdir -p "$TEMP_DIR"
    
    # Calculate duration for EIT
    local duration_hms
    duration_hms=$(printf "%02d:%02d:%02d" $((${CONFIG[BROADCAST_DURATION_SECONDS]%.*}/3600)) $(((${CONFIG[BROADCAST_DURATION_SECONDS]%.*}%3600)/60)) $((${CONFIG[BROADCAST_DURATION_SECONDS]%.*}%60)))
    
    # PAT - Program Association Table (critical for new PID creation)
    local pat_file="$TEMP_DIR/pat.xml"
    cat > "$pat_file" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<tsduck>
  <PAT version="3" current="true" transport_stream_id="${CONFIG[BROADCAST_TRANSPORT_STREAM_ID]}" network_PID="16">
    <service service_id="${CONFIG[BROADCAST_SERVICE_ID]}" program_map_PID="257"/>
  </PAT>
</tsduck>
EOF
    
    # CAT - Conditional Access Table
    local cat_file="$TEMP_DIR/cat.xml"
    cat > "$cat_file" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<tsduck>
  <CAT version="1" current="true">
  </CAT>
</tsduck>
EOF
    
    # PMT - Program Map Table (critical for new PID creation)
    local pmt_file="$TEMP_DIR/pmt.xml"
    cat > "$pmt_file" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<tsduck>
  <PMT version="12" current="true" service_id="${CONFIG[BROADCAST_SERVICE_ID]}" PCR_PID="273">
    <component elementary_PID="273" stream_type="0x02">
      <stream_identifier_descriptor component_tag="0"/>
    </component>
    <component elementary_PID="274" stream_type="0x0F">
      <stream_identifier_descriptor component_tag="16"/>
    </component>
  </PMT>
</tsduck>
EOF
    
    # NIT - Network Information Table
    local nit_file="$TEMP_DIR/nit.xml"
    cat > "$nit_file" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<tsduck>
  <NIT version="1" current="true" actual="true" network_id="${CONFIG[BROADCAST_ORIGINAL_NETWORK_ID]}">
    <network_name_descriptor network_name="${CONFIG[BROADCAST_NETWORK_NAME]}"/>
    <transport_stream transport_stream_id="${CONFIG[BROADCAST_TRANSPORT_STREAM_ID]}" 
                      original_network_id="${CONFIG[BROADCAST_ORIGINAL_NETWORK_ID]}">
      <service_list_descriptor>
        <service service_id="${CONFIG[BROADCAST_SERVICE_ID]}" service_type="1"/>
      </service_list_descriptor>
    </transport_stream>
  </NIT>
</tsduck>
EOF
    
    # EIT - Event Information Table (from generate_standalone_ts.sh)
    local eit_file="$TEMP_DIR/eit.xml"
    cat > "$eit_file" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<tsduck>
  <EIT version="1" current="true" actual="true" 
       service_id="${CONFIG[BROADCAST_SERVICE_ID]}" 
       transport_stream_id="${CONFIG[BROADCAST_TRANSPORT_STREAM_ID]}" 
       original_network_id="${CONFIG[BROADCAST_ORIGINAL_NETWORK_ID]}" 
       last_table_id="78"
       type="pf">
    <event event_id="1001" 
           start_time="${CONFIG[BROADCAST_START_TIME]}" 
           duration="$duration_hms" 
           running_status="running" 
           CA_mode="false">
      <short_event_descriptor language_code="jpn">
        <event_name>${CONFIG[BROADCAST_SERVICE_NAME]} Program</event_name>
        <text>ARIB compliant test stream</text>
      </short_event_descriptor>
      <component_descriptor stream_content="1" stream_content_ext="15" component_type="3" component_tag="0" language_code="jpn" text=""/>
      <content_descriptor>
        <content content_nibble_level_1="0" content_nibble_level_2="0" user_byte="0"/>
        <content content_nibble_level_1="1" content_nibble_level_2="0" user_byte="0"/>
      </content_descriptor>
    </event>
  </EIT>
</tsduck>
EOF
    
    # Generate SDT file with optimized structure (from generate_standalone_ts.sh)
    local sdt_file="$TEMP_DIR/sdt.xml"
    cat > "$sdt_file" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<tsduck>
  <SDT version="1" current="true" actual="true" 
       transport_stream_id="${CONFIG[BROADCAST_TRANSPORT_STREAM_ID]}" 
       original_network_id="${CONFIG[BROADCAST_ORIGINAL_NETWORK_ID]}">
    <service service_id="${CONFIG[BROADCAST_SERVICE_ID]}" 
             EIT_schedule="false" 
             EIT_present_following="true" 
             running_status="running" 
             CA_mode="false">
      <service_descriptor 
          service_type="1" 
          service_provider_name="${CONFIG[BROADCAST_SERVICE_PROVIDER]}" 
          service_name="${CONFIG[BROADCAST_SERVICE_NAME]}"/>
    </service>
  </SDT>
</tsduck>
EOF
    
    # Generate TDT file with JST support (new feature from generate_standalone_ts.sh)
    local tdt_file="$TEMP_DIR/tdt.xml"
    cat > "$tdt_file" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<tsduck>
  <TDT UTC_time="${CONFIG[BROADCAST_START_TIME]}"/>
</tsduck>
EOF
    
    # Generate TOT file with JST offset (new feature from generate_standalone_ts.sh)
    local tot_file="$TEMP_DIR/tot.xml"
    cat > "$tot_file" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<tsduck>
  <TOT UTC_time="${CONFIG[BROADCAST_START_TIME]}">
    <local_time_offset_descriptor>
      <region country_code="JPN" 
              country_region_id="0" 
              local_time_offset="540"
              time_of_change="2000-01-01 00:00:00"
              next_time_offset="540"/>
    </local_time_offset_descriptor>
  </TOT>
</tsduck>
EOF
    
    log "${GREEN}Generated comprehensive PSI/SI tables:${NC}"
    log "${GREEN}  PAT:${NC}         temp/pat.xml (Program Association Table)"
    log "${GREEN}  CAT:${NC}         temp/cat.xml (Conditional Access Table)"
    log "${GREEN}  PMT:${NC}         temp/pmt.xml (Program Map Table)"
    log "${GREEN}  NIT:${NC}         temp/nit.xml (Network Information Table)"
    log "${GREEN}  SDT:${NC}         temp/sdt.xml (Service Description Table)"
    log "${GREEN}  EIT:${NC}         temp/eit.xml (Event Information Table)"
    log "${GREEN}  TDT:${NC}         temp/tdt.xml (Time and Date Table)"
    log "${GREEN}  TOT:${NC}         temp/tot.xml (Time Offset Table)"
}

# Inject comprehensive PSI/SI metadata using generate_standalone_ts.sh approach
inject_eit_metadata() {
    if [[ "$INJECT_EIT" != true ]]; then
        log "${BLUE}Skipping EIT injection (--skip-eit specified)${NC}"
        return 0
    fi
    
    log "${BLUE}Injecting comprehensive PSI/SI metadata using generate_standalone_ts.sh method${NC}"
    
    local input_file="$TEMP_DIR/$FINAL_OUTPUT"
    local tables_dir="$TEMP_DIR"
    local output_file="$TEMP_DIR/${FINAL_OUTPUT%.ts}_with_metadata.ts"
    
    # Input file check
    if [[ ! -f "$input_file" ]]; then
        log "${RED}Error: Input file $input_file not found${NC}"
        return 1
    fi
    
    # Compile XML tables to binary (comprehensive approach from generate_standalone_ts.sh)
    log "${YELLOW}Compiling PSI/SI tables${NC}"
    local required_tables=("pat" "cat" "pmt" "nit" "sdt" "eit" "tdt" "tot")
    for table in "${required_tables[@]}"; do
        if [[ -f "$tables_dir/${table}.xml" ]]; then
            log "${BLUE}Compiling ${table}.xml${NC}"
            if ! tstabcomp --japan "$tables_dir/${table}.xml" -o "$tables_dir/${table}.bin" 2>> "$LOG_FILE"; then
                log "${RED}Error: Failed to compile ${table}.xml${NC}"
                log "${RED}Check log file: $LOG_FILE${NC}"
                return 1
            else
                log "${GREEN}✓ ${table}.bin compiled successfully${NC}"
            fi
        else
            log "${YELLOW}Warning: ${table}.xml not found, skipping${NC}"
        fi
    done
    
    # Optimized injection using single tsp pipeline (generate_standalone_ts.sh style)
    log "${YELLOW}Injecting PSI/SI tables using optimized method${NC}"
    
    # Use Amatsukaze-optimized frequencies (based on generate_standalone_ts.sh Line 260-271)
    local optimized_mode="${CONFIG[AMATSUKAZE_OPTIMIZED_MODE]:-true}"
    
    # Check which tables are available (comprehensive PSI/SI)
    local available_tables=()
    for table in pat cat pmt nit sdt eit tdt tot; do
        if [[ -f "$tables_dir/${table}.bin" ]]; then
            available_tables+=("$table")
            log "${GREEN}✓ ${table}.bin ready for injection${NC}"
        else
            log "${YELLOW}⚠ ${table}.bin not available${NC}"
        fi
    done
    
    if [[ ${#available_tables[@]} -eq 0 ]]; then
        log "${RED}Error: No PSI/SI tables available for injection${NC}"
        return 1
    fi
    
    log "${BLUE}Starting injection with ${#available_tables[@]} tables${NC}"
    
    if [[ "$optimized_mode" == "true" ]]; then
        # Comprehensive PSI/SI injection using generate_standalone_ts.sh approach
        log "${BLUE}Using comprehensive PSI/SI injection (generate_standalone_ts.sh compatible)${NC}"
        local tsp_cmd="tsp --japan -I file \"$input_file\""
        
        # PAT injection (PID 0) - critical foundation table
        if [[ -f "$tables_dir/pat.bin" ]]; then
            tsp_cmd="$tsp_cmd -P inject \"$tables_dir/pat.bin\" --pid 0 --replace"
        fi
        
        # CAT injection (PID 1) - new PID creation
        if [[ -f "$tables_dir/cat.bin" ]]; then
            tsp_cmd="$tsp_cmd -P inject \"$tables_dir/cat.bin\" --pid 1 --inter-packet 300"
        fi
        
        # NIT injection (PID 16) - new PID creation
        if [[ -f "$tables_dir/nit.bin" ]]; then
            tsp_cmd="$tsp_cmd -P inject \"$tables_dir/nit.bin\" --pid 16 --inter-packet 100"
        fi
        
        # SDT injection (PID 17) - service information
        if [[ -f "$tables_dir/sdt.bin" ]]; then
            tsp_cmd="$tsp_cmd -P inject \"$tables_dir/sdt.bin\" --pid 17 --replace"
        fi
        
        # EIT injection (PID 18) - event information (now with proper foundation)
        if [[ -f "$tables_dir/eit.bin" ]]; then
            tsp_cmd="$tsp_cmd -P inject \"$tables_dir/eit.bin\" --pid 18 --inter-packet 50"
        fi
        
        # TOT/TDT injection (PID 20) - time information
        if [[ -f "$tables_dir/tot.bin" ]]; then
            tsp_cmd="$tsp_cmd -P inject \"$tables_dir/tot.bin\" --pid 20 --inter-packet 150"
        elif [[ -f "$tables_dir/tdt.bin" ]]; then
            tsp_cmd="$tsp_cmd -P inject \"$tables_dir/tdt.bin\" --pid 20 --inter-packet 150"
        fi
        
        # PMT injection (PID 257) - program definition
        if [[ -f "$tables_dir/pmt.bin" ]]; then
            tsp_cmd="$tsp_cmd -P inject \"$tables_dir/pmt.bin\" --pid 257 --replace"
        fi
        
        tsp_cmd="$tsp_cmd -P continuity --fix -P regulate --bitrate 15000000 -O file \"$output_file\""
        
        log "${BLUE}Executing: $tsp_cmd${NC}"
        eval "$tsp_cmd" 2>&1 | tee -a "$LOG_FILE"
        local injection_result=${PIPESTATUS[0]}
        
        if [[ $injection_result -ne 0 ]]; then
            log "${RED}Error: TSDuck injection failed with exit code $injection_result${NC}"
            return 1
        fi
    else
        # Standard mode - comprehensive PSI/SI injection with standard frequencies
        log "${BLUE}Using standard mode comprehensive PSI/SI injection${NC}"
        local tsp_cmd="tsp --japan -I file \"$input_file\""
        
        # PAT injection (PID 0)
        if [[ -f "$tables_dir/pat.bin" ]]; then
            tsp_cmd="$tsp_cmd -P inject \"$tables_dir/pat.bin\" --pid 0 --replace"
        fi
        
        # CAT injection (PID 1)
        if [[ -f "$tables_dir/cat.bin" ]]; then
            tsp_cmd="$tsp_cmd -P inject \"$tables_dir/cat.bin\" --pid 1 --inter-packet 200"
        fi
        
        # NIT injection (PID 16)
        if [[ -f "$tables_dir/nit.bin" ]]; then
            tsp_cmd="$tsp_cmd -P inject \"$tables_dir/nit.bin\" --pid 16 --inter-packet 50"
        fi
        
        # SDT injection (PID 17)
        if [[ -f "$tables_dir/sdt.bin" ]]; then
            tsp_cmd="$tsp_cmd -P inject \"$tables_dir/sdt.bin\" --pid 17 --replace"
        fi
        
        # EIT injection (PID 18)
        if [[ -f "$tables_dir/eit.bin" ]]; then
            tsp_cmd="$tsp_cmd -P inject \"$tables_dir/eit.bin\" --pid 18 --inter-packet 30"
        fi
        
        # TOT/TDT injection (PID 20)
        if [[ -f "$tables_dir/tot.bin" ]]; then
            tsp_cmd="$tsp_cmd -P inject \"$tables_dir/tot.bin\" --pid 20 --inter-packet 200"
        elif [[ -f "$tables_dir/tdt.bin" ]]; then
            tsp_cmd="$tsp_cmd -P inject \"$tables_dir/tdt.bin\" --pid 20 --inter-packet 200"
        fi
        
        # PMT injection (PID 257)
        if [[ -f "$tables_dir/pmt.bin" ]]; then
            tsp_cmd="$tsp_cmd -P inject \"$tables_dir/pmt.bin\" --pid 257 --replace"
        fi
        
        tsp_cmd="$tsp_cmd -P continuity --fix -P regulate --bitrate 15000000 -O file \"$output_file\""
        
        log "${BLUE}Executing: $tsp_cmd${NC}"
        eval "$tsp_cmd" 2>&1 | tee -a "$LOG_FILE"
        local injection_result=${PIPESTATUS[0]}
        
        if [[ $injection_result -ne 0 ]]; then
            log "${RED}Error: TSDuck injection failed with exit code $injection_result${NC}"
            return 1
        fi
    fi
    
    # Result verification
    if [[ -f "$output_file" ]] && [[ -s "$output_file" ]]; then
        mv "$output_file" "$input_file"
        log "${GREEN}Optimized PSI/SI metadata injection completed successfully${NC}"
        
        # Enhanced verification with detailed output
        if command -v tsanalyze >/dev/null 2>&1; then
            log "${BLUE}Analyzing injected tables:${NC}"
            local verification_output
            verification_output=$(tsanalyze "$input_file" 2>/dev/null | grep -E "(EIT|SDT|TDT|TOT)" || true)
            if [[ -n "$verification_output" ]]; then
                echo "$verification_output"
                if echo "$verification_output" | grep -q "EIT"; then
                    log "${GREEN}✓ EIT table detected - event information should be available${NC}"
                else
                    log "${YELLOW}⚠ EIT table not detected in analysis${NC}"
                fi
                if echo "$verification_output" | grep -q -E "(TDT|TOT)"; then
                    log "${GREEN}✓ Time table detected - time information should be available${NC}"
                else
                    log "${YELLOW}⚠ Time table not detected in analysis${NC}"
                fi
            else
                log "${YELLOW}⚠ No PSI/SI tables detected in analysis${NC}"
            fi
        fi
        
        return 0
    else
        log "${RED}Error: PSI/SI metadata injection failed${NC}"
        return 1
    fi
}

# Verify Amatsukaze compatibility (from generate_standalone_ts.sh Line 299-338)
verify_amatsukaze_compatibility() {
    local output_file="$1"
    
    log "${BLUE}Verifying Amatsukaze compatibility${NC}"
    
    if [[ ! -f "$output_file" ]]; then
        log "${RED}Error: Output file not found for verification${NC}"
        return 1
    fi
    
    # PSI/SI structure verification (from generate_standalone_ts.sh Line 299-303)
    log "${YELLOW}PSI/SI structure verification:${NC}"
    if command -v tsanalyze >/dev/null 2>&1; then
        local structure_check
        structure_check=$(tsanalyze "$output_file" --japan --normalized 2>/dev/null | grep -E "pid:pid=(17|20):" | head -5 || true)
        if [[ -n "$structure_check" ]]; then
            echo "$structure_check"
        else
            log "${YELLOW}  Structure analysis: No PSI/SI tables detected${NC}"
        fi
    else
        log "${YELLOW}Warning: tsanalyze not available, skipping structure check${NC}"
    fi
    
    # Detailed Amatsukaze compatibility checks (from generate_standalone_ts.sh Line 308-320)
    log "${YELLOW}Amatsukaze compatibility checks:${NC}"
    
    # 1. Service information verification
    log "${BLUE}1. Service information:${NC}"
    if command -v tsp >/dev/null 2>&1; then
        local service_info
        service_info=$(tsp -I file "$output_file" -P tables --pid 17 --max 1 --text-output - -O drop 2>/dev/null | \
            grep -E "(Service|service_name)" | head -3 || true)
        if [[ -n "$service_info" ]]; then
            echo "$service_info"
        else
            log "${YELLOW}  Service info: Not detected${NC}"
        fi
    fi
    
    # 2. Time information verification
    log "${BLUE}2. Time information:${NC}"
    if command -v tsp >/dev/null 2>&1; then
        local time_info
        time_info=$(tsp -I file "$output_file" -P tables --pid 20 --max 1 --text-output - -O drop 2>/dev/null | \
            grep -E "(TOT|UTC_time)" | head -2 || true)
        if [[ -n "$time_info" ]]; then
            echo "$time_info"
        else
            log "${YELLOW}  Time info: Not detected${NC}"
        fi
    fi
    
    # 3. Event information verification
    log "${BLUE}3. Event information:${NC}"
    if command -v tsp >/dev/null 2>&1; then
        local event_info
        event_info=$(tsp -I file "$output_file" -P tables --pid 18 --max 1 --text-output - -O drop 2>/dev/null | \
            grep -E "(Event|event_name)" | head -3 || true)
        if [[ -n "$event_info" ]]; then
            echo "$event_info"
        else
            log "${YELLOW}  Event info: Not detected${NC}"
        fi
    fi
    
    # Amatsukaze test procedure display (from generate_standalone_ts.sh Line 331-338)
    log "${GREEN}Amatsukaze test procedure:${NC}"
    log "${GREEN}  1. Start Amatsukaze${NC}"
    log "${GREEN}  2. [Queue] > [Add] select: $output_file${NC}"
    log "${GREEN}  3. Verify the following are displayed:${NC}"
    log "${GREEN}     ✅ Genre information${NC}"
    log "${GREEN}     ✅ Resolution information${NC}"
    log "${GREEN}     ✅ Channel name: ${CONFIG[BROADCAST_SERVICE_NAME]}${NC}"
    log "${GREEN}     ✅ Time info: ${CONFIG[BROADCAST_START_TIME]}${NC}"
    
    return 0
}

# Move final output from temp to output directory
move_final_output() {
    log "${BLUE}Moving final output to destination${NC}"
    
    mkdir -p "$OUTPUT_DIR"
    
    local temp_file="$TEMP_DIR/$FINAL_OUTPUT"
    local output_file="$OUTPUT_DIR/$FINAL_OUTPUT"
    
    if [[ ! -f "$temp_file" ]]; then
        log "${RED}Error: Final output file $temp_file not found${NC}"
        return 1
    fi
    
    # Move the final file to output directory
    mv "$temp_file" "$output_file"
    
    if [[ -f "$output_file" ]]; then
        local file_size
        file_size=$(stat -c%s "$output_file" 2>/dev/null | numfmt --to=iec || echo "unknown")
        local eit_status=""
        if [[ "$INJECT_EIT" == true ]]; then
            eit_status=" (with EIT metadata)"
        fi
        log "${GREEN}Final output ready: $output_file$eit_status ($file_size)${NC}"
        return 0
    else
        log "${RED}Error: Failed to move final output${NC}"
        return 1
    fi
}

# Generate report
generate_report() {
    log "${BLUE}Generating report${NC}"
    
    local report_file="$OUTPUT_DIR/generation_report.txt"
    local csv_file="$OUTPUT_DIR/segment_structure.csv"
    
    {
        echo "TV Sample Generation Report"
        echo "=========================="
        echo "Generated: $(date)"
        echo "Configuration: $CONFIG_FILE"
        local eit_note=""
        if [[ "$INJECT_EIT" == true ]]; then
            eit_note=" (with EIT metadata)"
        fi
        echo "Output: $OUTPUT_DIR/$FINAL_OUTPUT $eit_note"
        echo ""
        echo "Technical Specifications:"
        echo "- Video:             ${CONFIG[VIDEO_WIDTH]}x${CONFIG[VIDEO_HEIGHT]} ${CONFIG[VIDEO_ASPECT]} ${CONFIG[FRAME_RATE]}fps"
        echo "- Video Codec:       ${CONFIG[VIDEO_CODEC]} ${CONFIG[VIDEO_BITRATE]}"
        echo "- Audio:             ${CONFIG[AUDIO_SAMPLE_RATE]}Hz ${CONFIG[AUDIO_CHANNELS]}ch ${CONFIG[AUDIO_BITRATE]}"
        echo "- Audio Levels:      0VU=${CONFIG[AUDIO_LEVEL_0VU]}dBFS, Silence<${CONFIG[AUDIO_SILENCE_THRESHOLD]}dBFS"
        echo ""
        echo "Broadcast Metadata:"
        echo "- Service ID:        ${CONFIG[BROADCAST_SERVICE_ID]}"
        echo "- Transport Stream:  ${CONFIG[BROADCAST_TRANSPORT_STREAM_ID]}"
        echo "- Original Network:  ${CONFIG[BROADCAST_ORIGINAL_NETWORK_ID]}"
        echo "- Service Name:      \"${CONFIG[BROADCAST_SERVICE_NAME]}\""
        echo "- Service Provider:  \"${CONFIG[BROADCAST_SERVICE_PROVIDER]}\""
        echo "- Network Name:      \"${CONFIG[BROADCAST_NETWORK_NAME]}\""
        if [[ "$INJECT_EIT" == true ]]; then
            echo "- EIT Start Time:    ${CONFIG[BROADCAST_START_TIME]}"
            echo "- EIT Status:        Present/Following enabled"
        else
            echo "- EIT Status:        Disabled (--skip-eit specified)"
        fi
        echo ""
        echo "EIT/SDT/TDT Metadata Files:"
        if [[ -f "$TEMP_DIR/eit.xml" ]]; then
            echo "- EIT (Event Information Table):     Generated"
            echo "  File: $TEMP_DIR/eit.xml"
            if [[ "$INJECT_EIT" == true ]]; then
                echo "  Status: Injected into final output"
            else
                echo "  Status: Generated but not injected (--skip-eit)"
            fi
        else
            echo "- EIT (Event Information Table):     Not generated"
        fi
        if [[ -f "$TEMP_DIR/sdt.xml" ]]; then
            echo "- SDT (Service Description Table):   Generated"
            echo "  File: $TEMP_DIR/sdt.xml"
            echo "  Status: Injected into final output"
        else
            echo "- SDT (Service Description Table):   Not generated"
        fi
        if [[ -f "$TEMP_DIR/tdt.xml" ]]; then
            echo "- TDT (Time and Date Table):         Generated"
            echo "  File: $TEMP_DIR/tdt.xml"
            echo "  Status: Injected into final output"
        else
            echo "- TDT (Time and Date Table):         Not generated"
        fi
        echo ""
        echo "Segment Structure:"
        local segment_count=0
        for segment_data in "${SEGMENTS[@]}"; do
            IFS=',' read -r type name start_frame end_frame <<< "$segment_data"
            [[ "$type" == "RecMargin" ]] && continue
            local frame_duration=$((end_frame - start_frame + 1))
            local time_duration
            time_duration=$(calculate_duration "$start_frame" $((end_frame + 1)))
            printf "  %2d. %-12s: %5d frames (%7.3fs)\n" $((++segment_count)) "$name" "$frame_duration" "$time_duration"
        done
    } > "$report_file"
    
    # CSV for external processing
    echo "Segment,Type,StartFrame,EndFrame,Duration_Frames,Duration_Seconds" > "$csv_file"
    segment_count=0
    for segment_data in "${SEGMENTS[@]}"; do
        IFS=',' read -r type name start_frame end_frame <<< "$segment_data"
        [[ "$type" == "RecMargin" ]] && continue
        local frame_duration=$((end_frame - start_frame + 1))
        local time_duration
        time_duration=$(calculate_duration "$start_frame" $((end_frame + 1)))
        echo "$name,$type,$start_frame,$end_frame,$frame_duration,$time_duration" >> "$csv_file"
        segment_count=$((segment_count + 1))
    done
    
    log "${GREEN}Report generated: $report_file${NC}"
    log "${GREEN}CSV structure: $csv_file${NC}"
}

# Cleanup temporary files
cleanup() {
    if [[ "$DEBUG" == true ]] || [[ "${1:-}" == "keep" ]]; then
        log "${YELLOW}Keeping temporary files in $TEMP_DIR (debug mode)${NC}"
    else
        log "${BLUE}Cleaning up temporary files${NC}"
        rm -rf "$TEMP_DIR"
    fi
}

# Check system dependencies and ffmpeg capabilities
check_dependencies() {
    log "${BLUE}Checking system dependencies and capabilities${NC}"
    
    local missing_deps=()
    local ffmpeg_issues=()
    
    # Check basic commands
    local required_commands=("ffmpeg" "ffprobe" "bc" "grep" "awk" "md5sum" "jq")
    for cmd in "${required_commands[@]}"; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            missing_deps+=("$cmd")
        fi
    done
    
    # Check TSDuck if EIT injection is enabled (default)
    if [[ "$INJECT_EIT" == true ]]; then
        if ! command -v "tsp" >/dev/null 2>&1; then
            log "${RED}Error: TSDuck is required but not found.${NC}"
            show_tsduck_install_instructions
            exit 1
        else
            # Check TSDuck version (require 3.41+)
            local tsduck_version
            tsduck_version=$(tsp --version 2>&1 | head -1 | grep -o '[0-9]\+\.[0-9]\+' | head -1)
            if [[ -n "$tsduck_version" ]]; then
                local version_check
                version_check=$(echo "$tsduck_version >= 3.41" | bc 2>/dev/null)
                if [[ "$version_check" != "1" ]]; then
                    log "${RED}Error: TSDuck version $tsduck_version is too old. Version 3.41 or higher is required.${NC}"
                    show_tsduck_install_instructions
                    exit 1
                fi
            else
                log "${YELLOW}Warning: Could not determine TSDuck version. Proceeding anyway...${NC}"
            fi
        fi
    fi
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        log "${RED}Error: Missing required commands: ${missing_deps[*]}${NC}"
        log "${YELLOW}Please install the missing dependencies:${NC}"
        for dep in "${missing_deps[@]}"; do
            case "$dep" in
                "ffmpeg"|"ffprobe") log "  - FFmpeg: https://ffmpeg.org/download.html" ;;
                "bc") log "  - bc: sudo apt-get install bc (Ubuntu/Debian) or brew install bc (macOS)" ;;
                "jq") log "  - jq: sudo apt-get install jq (Ubuntu/Debian) or brew install jq (macOS)" ;;
                "tsp (TSDuck)") log "  - TSDuck: https://tsduck.io/download/tsduck/" ;;
                *) log "  - $dep: available in most standard Unix environments" ;;
            esac
        done
        exit 1
    fi
    
    # Check FFmpeg capabilities
    log "${BLUE}Verifying FFmpeg codec and filter support${NC}"
    
    # Basic FFmpeg functionality test
    if ! ffmpeg -f lavfi -i "testsrc=size=320x240:duration=1" -t 1 -f null - 2>/dev/null; then
        ffmpeg_issues+=("FFmpeg basic video generation not working")
    fi
    
    # Check for H.264 support (warn if not available)
    if ! ffmpeg -codecs 2>/dev/null | grep -qi "264"; then
        log "${YELLOW}Warning: H.264 codec may not be available, --h264 option may not work${NC}"
    fi
    
    # Essential capability warnings (non-fatal)
    local warnings=()
    
    if ! ffmpeg -codecs 2>/dev/null | grep -qi "mpeg2"; then
        warnings+=("MPEG-2 video codec")
    fi
    
    if ! ffmpeg -codecs 2>/dev/null | grep -qi "aac"; then
        warnings+=("AAC audio codec")  
    fi
    
    if ! ffmpeg -filters 2>/dev/null | grep -qi "drawtext"; then
        warnings+=("drawtext filter for text overlay")
    fi
    
    if ! ffmpeg -muxers 2>/dev/null | grep -qi "mpegts"; then
        warnings+=("MPEG-TS muxer")
    fi
    
    if [[ ${#warnings[@]} -gt 0 ]]; then
        log "${YELLOW}Warnings - Some features may be limited:${NC}"
        for warning in "${warnings[@]}"; do
            log "${YELLOW}  - $warning may not be available${NC}"
        done
        log "${YELLOW}Script will attempt to run with available codecs/filters${NC}"
    fi
    
    if [[ ${#ffmpeg_issues[@]} -gt 0 ]]; then
        log "${RED}Error: FFmpeg configuration issues detected:${NC}"
        for issue in "${ffmpeg_issues[@]}"; do
            log "${RED}  - $issue${NC}"
        done
        log "${YELLOW}Please install a complete FFmpeg build with all required codecs and filters.${NC}"
        log "${YELLOW}Recommended: Use official FFmpeg builds or install via package manager.${NC}"
        exit 1
    fi
    
    # Display FFmpeg version info
    local ffmpeg_version
    ffmpeg_version=$(ffmpeg -version 2>/dev/null | head -1 | cut -d' ' -f3)
    log "${GREEN}✓ All dependencies available${NC}"
    log "${GREEN}✓ FFmpeg version: $ffmpeg_version${NC}"
    log "${GREEN}✓ All required codecs and filters available${NC}"
}

# Main execution
main() {
    log "${GREEN}=== TV Sample Generator Started ===${NC}"
    log "Timestamp: $(date)"
    
    # Check dependencies first
    check_dependencies
    
    # Initialize log
    : > "$LOG_FILE"
    
    # Process
    load_config
    generate_metadata_files
    preview_segments
    generate_segments
    concatenate_segments
    inject_eit_metadata
    move_final_output
    generate_report
    
    # Enhanced verification with Amatsukaze compatibility check
    local final_output_path="$OUTPUT_DIR/$FINAL_OUTPUT"
    if [[ -f "$final_output_path" ]]; then
        log "${BLUE}Technical verification:${NC}"
        ffprobe -v quiet -print_format json -show_format "$final_output_path" 2>/dev/null | \
            jq -r '.format | "Duration: \(.duration)s, Size: \(.size) bytes, Bitrate: \(.bit_rate) bps"' 2>/dev/null || \
            ffprobe -v error -show_entries format=duration,size,bit_rate -of csv=p=0 "$final_output_path"
        
        # Run Amatsukaze compatibility verification (new feature)
        verify_amatsukaze_compatibility "$final_output_path"
    fi
    
    cleanup "${1:-}"
    log "${GREEN}=== TV Sample Generator Completed ===${NC}"
}

# Script execution
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
