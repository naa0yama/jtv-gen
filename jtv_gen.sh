#!/usr/bin/env bash

# Japanese TV Content Generator (JTV Gen) Script
# Generates Japanese TV broadcast dummy files

set -euo pipefail

# ==============================================================================
# GLOBAL CONFIGURATION AND VARIABLES
# ==============================================================================
# Default configuration
DEBUG=false
CONFIG_FILE="scene_06min.conf"
CONFIG_BASENAME=$(basename "$CONFIG_FILE" .conf)
OUTPUT_DIR="output/${CONFIG_BASENAME}"
TEMP_DIR="temp/${CONFIG_BASENAME}"
NO_COLOR="${NO_COLOR:-no}"
LOG_FILE="tv_generation.log"
# Output filename for MPEG-2 TS format
FINAL_OUTPUT=""

# Default broadcast metadata (can be overridden in config file)
DEFAULT_SERVICE_ID=65024  # 0xFE00 - For technical testing
DEFAULT_TRANSPORT_STREAM_ID=$(( (RANDOM % 65535) + 1 ))
DEFAULT_ORIGINAL_NETWORK_ID=$(( (RANDOM % 65535) + 1 ))
DEFAULT_SERVICE_NAME="JTV Gen"
DEFAULT_SERVICE_PROVIDER="FFmpeg"
DEFAULT_NETWORK_NAME="Generated by naa0yama"
DEFAULT_START_TIME="2024-12-31 15:00:00"

# Colors for output (initialized here for use in cleanup)
if [[ "${NO_COLOR}" == "no" ]]; then
	declare -A COLORS=(
		["red"]='\033[0;31m'	["green"]='\033[0;32m'	["yellow"]='\033[0;33m'
		["blue"]='\033[0;34m'	["purple"]='\033[0;35m'	["cyan"]='\033[0;36m'
		["white"]='\033[0;37m'	["bold"]='\033[1m'		["reset"]='\033[0m'
	)
else
	declare -A COLORS=(
		["red"]=''				["green"]=''			["yellow"]=''
		["blue"]=''				["purple"]=''			["cyan"]=''
		["white"]=''			["bold"]=''				["reset"]=''
	)
fi

# Global arrays (loaded from config)
declare -A CONFIG
declare -a SEGMENTS

# ============================================================================
# TRAP HANDLERS FOR CLEANUP
# ============================================================================

# Cleanup function for trap handlers
cleanup_on_exit() {
	local exit_code=$?

	# Check if we're being called from a trap
	local from_trap=false
	if [[ "${BASH_SUBSHELL}" == "0" ]] && [[ -n "${BASH_LINENO[1]}" ]]; then
		from_trap=true
	fi

	if [[ $exit_code -ne 0 ]]; then
		logger "Script interrupted or failed (exit code: $exit_code)" red
	fi

	# Reset terminal state - always do this to ensure proper cleanup
	stty sane 2>/dev/null || true
	tput sgr0 2>/dev/null || true  # Reset terminal attributes
	printf "\n"  # Ensure prompt appears on new line

	# Clean up temporary files if they exist
	if [[ -d "$TEMP_DIR" ]]; then
		if [[ "$DEBUG" == true ]]; then
			logger "Keeping temporary files in $TEMP_DIR (debug mode)" yellow
		else
			logger "Cleaning up temporary files in $TEMP_DIR" yellow
			rm -rf "$TEMP_DIR"
		fi
	fi

	# Kill any background ffmpeg processes
	if pgrep -f "ffmpeg.*$TEMP_DIR" > /dev/null 2>&1; then
		logger "Terminating background ffmpeg processes" yellow
		pkill -f "ffmpeg.*$TEMP_DIR" 2>/dev/null || true
	fi

	# Kill any background segment generation processes
	if pgrep -f "process_segment_async" > /dev/null 2>&1; then
		logger "Terminating background segment generation processes" yellow
		pkill -f "process_segment_async" 2>/dev/null || true
	fi

	if [[ $exit_code -ne 0 ]]; then
		if [[ "$DEBUG" == true ]]; then
			logger "Generation failed. Temporary files kept in $TEMP_DIR for debugging." red
		else
			logger "Generation failed. All temporary files have been cleaned up." red
		fi
	fi

	# Reset terminal one more time before final exit
	if [[ "$from_trap" == false ]]; then
		# Final terminal reset to ensure prompt visibility
		stty sane 2>/dev/null || true
		tput sgr0 2>/dev/null || true
		printf "\n"  # Extra newline for prompt
		exit $exit_code
	fi
}

# Signal handler for interruption (INT/TERM)
handle_interrupt() {
	local signal=$1
	logger "Received signal $signal - initiating cleanup..." yellow

	# Reset terminal state immediately and thoroughly
	stty sane 2>/dev/null || true
	tput sgr0 2>/dev/null || true  # Reset terminal attributes
	printf "\n"  # Ensure clean line for prompt

	# Set exit code for cleanup function
	exit 130  # Standard exit code for Ctrl+C
}

# Set up trap handlers
trap cleanup_on_exit EXIT
trap 'handle_interrupt INT' INT
trap 'handle_interrupt TERM' TERM

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

# Logging function
logger() {
	local message="${1}"
	local color="${2:-none}"

	# Colored output to terminal
	if [[ "${color}" == "none" ]]; then
		echo -e "${message}"
	else
		echo -e "${COLORS[$color]}${message}${COLORS[reset]}"
	fi

	# Output to log file without color
	local log_dir=$(dirname "${LOG_FILE}")
	[[ ! -d "${log_dir}" ]] && mkdir -p "${log_dir}"
	echo "${message}" >> "${LOG_FILE}"
}

# Show TSDuck installation instructions with latest release info
show_tsduck_install_instructions() {
	logger "TSDuck Installation Instructions:" yellow
	logger ""

	# Try to get latest release info from GitHub API with proper User-Agent
	local latest_info
	local user_agent="JTV-Gen/1.0 (https://github.com/naa0yama/jtv-gen)"

	if command -v curl >/dev/null 2>&1; then
		latest_info=$(curl -s -H "User-Agent: $user_agent" "https://api.github.com/repos/tsduck/tsduck/releases/latest" 2>/dev/null)
	elif command -v wget >/dev/null 2>&1; then
		latest_info=$(wget --user-agent="$user_agent" -qO- "https://api.github.com/repos/tsduck/tsduck/releases/latest" 2>/dev/null)
	fi

	if [[ -n "$latest_info" ]] && command -v grep >/dev/null 2>&1; then
		# Extract version and Ubuntu 24.04 deb file URL
		local version tag_name ubuntu24_url
		version=$(echo "$latest_info" | grep '"tag_name"' | head -1 | sed 's/.*"tag_name": *"\([^"]*\)".*/\1/')
		tag_name="$version"
		ubuntu24_url=$(echo "$latest_info" | grep '"browser_download_url"' | grep 'ubuntu24.*\.deb' | head -1 | sed 's/.*"browser_download_url": *"\([^"]*\)".*/\1/')

		if [[ -n "$version" ]] && [[ -n "$ubuntu24_url" ]]; then
			logger "Latest Release: $version" green
			logger ""
			logger "= Ubuntu 24.04 LTS:" blue
			logger "wget \"$ubuntu24_url\""
			logger "sudo apt --fix-broken install \"./$(basename "$ubuntu24_url")\""
			logger ""
			logger "= Other Ubuntu/Debian versions:" blue
			logger "Check available packages at: https://github.com/tsduck/tsduck/releases/tag/$tag_name"
		else
			# API response malformed, use fallback
			show_tsduck_fallback_instructions
		fi
	else
		# API not available, use fallback
		show_tsduck_fallback_instructions
	fi

	logger ""
	logger "= Alternative installation methods:" blue
	logger "- Use package manager if available for your distribution"
	logger "- Build from source: https://github.com/tsduck/tsduck"
	logger ""
}

# Show fallback TSDuck installation instructions
show_tsduck_fallback_instructions() {
	logger "= Installation Instructions:" blue
	logger "1. Visit the official download page:"
	logger "   https://tsduck.io/download/tsduck/"
	logger ""
	logger "2. Download the appropriate package for your system:"
	logger "   - Ubuntu/Debian: .deb packages"
	logger ""
	logger "3. Install the downloaded package:"
	logger "   For Ubuntu/Debian:" blue
	logger "   sudo apt install ./tsduck_*.deb"
	logger ""
	logger "4. Verify installation:"
	logger "   tsp --version"
}

# Show comprehensive help
show_help() {
	cat << EOF
================================================================================
Japanese TV Content Generator (JTV Gen) - Japanese TV Broadcast Dummy File Creator
================================================================================

DESCRIPTION:
	Generates Japanese TV broadcast dummy files in MPEG-TS
	format, including main program segments, commercial segments with Japanese
	broadcasting standards (15-second intervals), transparent logos, and proper
	audio levels following ARIB specifications.

USAGE:
	./jtv_gen.sh [OPTIONS]

OPTIONS:
	--debug              Enable verbose debug output
	-c, --config FILE    Configuration file (default: ${CONFIG_FILE})
	-y, --yes            Skip confirmation prompt and start generation immediately
	-h, --help           Show this comprehensive help message

EXAMPLES:
	# Generate using default configuration
	./jtv_gen.sh

	# Generate with debug output enabled
	./jtv_gen.sh --debug

	# Use custom configuration file
	./jtv_gen.sh -c ${CONFIG_FILE}

	# Debug mode with custom config
	./jtv_gen.sh --debug -c ${CONFIG_FILE}

CONFIGURATION:
	The script uses configuration files to define:
	- Program structure (main segments, CM segments, timing)
	- Technical specifications (resolution, bitrate, audio levels)
	- Japanese broadcasting standards compliance

OUTPUT:
	The generated MPEG-TS file will be named based on the configuration:
	- scene_01min.conf → ${OUTPUT_DIR}/jtv_scene_01min.ts

TECHNICAL SPECIFICATIONS:
	- Video: MPEG-2, 1440x1080, 16:9 aspect, 29.97fps interlaced
	- Audio: AAC-LC, 48kHz, stereo, Japanese broadcast levels
	- Container: MPEG-TS with proper stream IDs
	- Standards: ARIB compliant for Japanese terrestrial broadcasting

FEATURES:
	✓ Main program segments with transparent logos
	✓ Commercial segments following 15-second Japanese standards
	✓ Silent periods with color inversion around commercials
	✓ Japanese audio level standards (-20dBFS for 0VU reference)
	✓ Configurable program structure via CSV-like format
	✓ Professional broadcast-quality output
	✓ Automatic cleanup on interruption or failure

REQUIREMENTS:
	- ffmpeg (with MPEG-2 and AAC encoding support)
	- bc (for duration calculations)
	- Standard Unix tools (grep, awk, etc.)
	- TSDuck (for EIT metadata injection): https://tsduck.io/download/tsduck/

INTERRUPT HANDLING:
	The script handles interruptions (Ctrl+C, SIGTERM) gracefully:
	- Terminates any running ffmpeg processes
	- Cleans up temporary files automatically
	- Provides clear status messages

FILES CREATED:
	- ${OUTPUT_DIR}/jtv_[config].ts         Final MPEG-TS output
	- ${OUTPUT_DIR}/generation_report.txt   Detailed generation report
	- ${OUTPUT_DIR}/segment_structure.csv   Segment timing data
	- tv_generation.log                     Generation log file
	- temp/                                 Temporary files (auto-cleaned)

For more information about configuration format and technical details,
see the configuration files and generated reports.

================================================================================
EOF
}

# ============================================================================
# ARGUMENT PARSING
# ============================================================================

# Parse command line arguments
SKIP_CONFIRMATION=false
while [[ $# -gt 0 ]]; do
	case $1 in
		--debug)
			DEBUG=true
			shift
			;;
		-c|--config)
			CONFIG_FILE="$2"
			shift 2
			;;
		-y|--yes)
			SKIP_CONFIRMATION=true
			shift
			;;
		-h|--help)
			show_help
			exit 0
			;;
		*)
			echo "Unknown option: $1"
			echo "Usage: $0 [--debug] [-c|--config CONFIG_FILE] [-y|--yes] [-h|--help] (default: ${CONFIG_FILE})"
			echo "Use $0 --help for detailed information."
			exit 1
			;;
	esac
done

# ============================================================================
# CORE FUNCTIONS
# ============================================================================
# Load configuration
load_config() {
	logger "Loading configuration from $CONFIG_FILE" blue

	if [[ ! -f "$CONFIG_FILE" ]]; then
		if [[ "$CONFIG_FILE" = "scene_06min.conf" ]]; then
			cat > "scene_06min.conf" << EOF
# TV Program Configuration
# Format: SECTION_TYPE,SECTION_NAME,START_FRAME,END_FRAME
# SECTION_TYPE: RecMargin, Main, CM
# START_FRAME,END_FRAME: Frame range (29.97fps)

# Program Structure
SECTION_TYPE,SECTION_NAME,START_FRAME,END_FRAME
Main,Main_1,0,1198
CM,CM1-1,1199,2097
Main,Main_2,2098,7191
CM,CM2-1,7192,7641
CM,CM2-2,7642,8540
CM,CM2-3,8541,8990
CM,CM2-4,8991,9439
CM,CM2-5,9440,9888
CM,CM2-6,9889,10338
CM,CM2-7,10339,10793
EOF
		fi
		logger "Warning: configuration file $CONFIG_FILE defualt created" yellow
	fi

	# Default variables
	CONFIG["FRAME_RATE"]=30000/1001
	CONFIG["VIDEO_WIDTH"]=1440
	CONFIG["VIDEO_HEIGHT"]=1080
	CONFIG["VIDEO_CODEC"]=mpeg2video
	CONFIG["VIDEO_BITRATE_MIN"]=1M
	CONFIG["VIDEO_BITRATE_AVG"]=6M
	CONFIG["VIDEO_BITRATE_MAX"]=12M

	CONFIG["AUDIO_CODEC"]=aac
	CONFIG["AUDIO_PROFILE"]=aac_low
	CONFIG["AUDIO_BITRATE"]=248k
	CONFIG["AUDIO_SAMPLE_RATE"]=48000
	CONFIG["AUDIO_CHANNELS"]=2

	# Load technical settings - simplified approach
	while IFS='=' read -r key value; do
		# Skip comments and empty lines
		[[ "$key" =~ ^# ]] && continue
		[[ -z "$key" ]] && continue

		if [[ -n "$key" ]] && [[ -n "$value" ]]; then
			CONFIG["$key"]="$value"
			# echo "Loaded: $key=$value" >&2
		fi
	done < <(grep '^[A-Z_0-9]*=' "$CONFIG_FILE")

	# Set broadcast metadata with defaults if not specified in config
	CONFIG["BROADCAST_SERVICE_ID"]="${DEFAULT_SERVICE_ID}"
	CONFIG["BROADCAST_TRANSPORT_STREAM_ID"]="${DEFAULT_TRANSPORT_STREAM_ID}"
	CONFIG["BROADCAST_ORIGINAL_NETWORK_ID"]="${DEFAULT_ORIGINAL_NETWORK_ID}"
	CONFIG["BROADCAST_SERVICE_NAME"]="${DEFAULT_SERVICE_NAME}"
	CONFIG["BROADCAST_SERVICE_PROVIDER"]="${DEFAULT_SERVICE_PROVIDER}"
	CONFIG["BROADCAST_NETWORK_NAME"]="${DEFAULT_NETWORK_NAME}"
	CONFIG["BROADCAST_START_TIME"]="${DEFAULT_START_TIME}"

	# Load segment structure - now with START_FRAME,END_FRAME format
	local in_segments=false
	local prev_end_frame=-1
	local line_num=0
	while IFS=',' read -r type name start_frame end_frame; do
		line_num=$((line_num + 1))
		# Skip comments and empty lines
		[[ "$type" =~ ^# ]] && continue
		[[ -z "$type" ]] && continue

		if [[ "$type" == "SECTION_TYPE" ]]; then
			in_segments=true
			continue
		fi

		# Only process segment data, not config data
		if [[ $in_segments == true ]] && [[ "$type" =~ ^(Main|CM)$ ]] && [[ -n "$start_frame" ]] && [[ -n "$end_frame" ]]; then
			# Validate frame continuity - START must be previous END + 1
			if [[ $prev_end_frame -ge 0 ]] && [[ $start_frame -ne $((prev_end_frame + 1)) ]]; then
				logger "Error: Frame continuity broken at line $line_num ($type,$name)" red
				logger "Previous END_FRAME=$prev_end_frame, current START_FRAME=$start_frame" red
				logger "Expected START_FRAME=$((prev_end_frame + 1)) (previous END + 1)" red
				exit 1
			fi

			SEGMENTS+=("$type,$name,$start_frame,$end_frame")
			prev_end_frame=$end_frame
			# echo "DEBUG: Added segment: $type,$name,$start_frame,$end_frame" >&2
		fi
	done < "$CONFIG_FILE"

	logger "Loaded ${#SEGMENTS[@]} segments and ${#CONFIG[@]} configuration parameters" green

	# Calculate total duration from segments for metadata generation
	local max_end_frame=0
	for segment_data in "${SEGMENTS[@]}"; do
		IFS=',' read -r type name start_frame end_frame <<< "$segment_data"
		if [[ $end_frame -gt $max_end_frame ]]; then
			max_end_frame=$end_frame
		fi
	done
	CONFIG["BROADCAST_DURATION_FRAMES"]=$max_end_frame
	local duration_seconds
	duration_seconds=$(calculate_duration 0 "$max_end_frame")
	CONFIG["BROADCAST_DURATION_SECONDS"]="$duration_seconds"

	# Set final output filename
	FINAL_OUTPUT="jtv_${CONFIG_BASENAME}.ts"
}

# Calculate frame duration from frame numbers
calculate_duration() {
	local start_frame=$1
	local end_frame=$2
	local frame_rate=(${CONFIG["FRAME_RATE"]//// })
	local fps_num=${frame_rate[0]}
	local fps_den=${frame_rate[1]}

	local frame_count=$((end_frame - start_frame))
	local duration
	duration=$(echo "scale=6; $frame_count * $fps_den / $fps_num" | bc -l)
	echo "$duration"
}

# Format duration in seconds to HH:MM:SS.mmm format
format_duration() {
	local duration_seconds=$1
	local hours minutes seconds milliseconds

	# Convert to integer calculations to avoid printf issues
	local total_ms_str
	total_ms_str=$(echo "scale=0; $duration_seconds * 1000 / 1" | bc -l)
	# Ensure it's an integer by removing any decimal point
	local total_ms=${total_ms_str%.*}

	hours=$((total_ms / 3600000))
	local remaining_ms=$((total_ms - hours * 3600000))

	minutes=$((remaining_ms / 60000))
	remaining_ms=$((remaining_ms - minutes * 60000))

	seconds=$((remaining_ms / 1000))
	milliseconds=$((remaining_ms % 1000))

	printf "%02dh %02dm %02d.%03ds" "$hours" "$minutes" "$seconds" "$milliseconds"
}

# Show media specifications summary
show_media_specs() {
	local duration_formatted
	duration_formatted=$(printf "%02d:%02d:%02d" $((${CONFIG[BROADCAST_DURATION_SECONDS]%.*}/3600)) $(((${CONFIG[BROADCAST_DURATION_SECONDS]%.*}%3600)/60)) $((${CONFIG[BROADCAST_DURATION_SECONDS]%.*}%60)))

	logger "${COLORS[green]}Video:${COLORS[reset]}         MPEG-2, progressive, ${CONFIG[VIDEO_WIDTH]}x${CONFIG[VIDEO_HEIGHT]} [SAR 4:3, DAR 16:9]"
	logger "               ${CONFIG[FRAME_RATE]} fps, bitrate min ${CONFIG[VIDEO_BITRATE_MIN]}, avg ${CONFIG[VIDEO_BITRATE_AVG]}, maxrate ${CONFIG[VIDEO_BITRATE_MAX]}"
	logger "${COLORS[green]}Audio:${COLORS[reset]}         ${CONFIG[AUDIO_CODEC]}, ${CONFIG[AUDIO_SAMPLE_RATE]}Hz, ${CONFIG[AUDIO_CHANNELS]}ch, ${CONFIG[AUDIO_BITRATE]}"
	logger "${COLORS[green]}Duration:${COLORS[reset]}      $duration_formatted (${CONFIG[BROADCAST_DURATION_FRAMES]} frames)"
	logger "${COLORS[green]}Broadcast:${COLORS[reset]}     Service ID ${CONFIG[BROADCAST_SERVICE_ID]}, Transport Stream ID ${CONFIG[BROADCAST_TRANSPORT_STREAM_ID]}"
	logger "               Service: \"${CONFIG[BROADCAST_SERVICE_NAME]}\" by \"${CONFIG[BROADCAST_SERVICE_PROVIDER]}\""
	logger "               Network: \"${CONFIG[BROADCAST_NETWORK_NAME]}\""

	logger "${COLORS[green]}EIT Metadata:${COLORS[reset]}  Start time ${CONFIG[BROADCAST_START_TIME]} UTC, Present/Following enabled"
}

# Convert frame number to HH:MM:SS.FF format
frame_to_timecode() {
	local frame=$1
	local frame_rate=(${CONFIG["FRAME_RATE"]//// })
	local fps_num=${frame_rate[0]}
	local fps_den=${frame_rate[1]}
	local fps
	fps=$(echo "scale=6; $fps_num / $fps_den" | bc -l)

	# Calculate total seconds
	local total_seconds
	total_seconds=$(echo "scale=6; $frame * $fps_den / $fps_num" | bc -l)

	# Extract hours, minutes, seconds, and frame
	local hours
	hours=$(echo "$total_seconds / 3600" | bc)
	local remaining
	remaining=$(echo "scale=6; $total_seconds - $hours * 3600" | bc -l)
	local minutes
	minutes=$(echo "$remaining / 60" | bc)
	local seconds
	seconds=$(echo "scale=6; $remaining - $minutes * 60" | bc -l)

	# Calculate frame within the second
	local frame_in_second
	frame_in_second=$(echo "scale=0; ($seconds - ($seconds / 1 * 1)) * $fps" | bc -l)
	local whole_seconds
	whole_seconds=$(echo "scale=0; $seconds / 1" | bc)

	printf "%02d:%02d:%02d.%02.0f" "$hours" "$minutes" "$whole_seconds" "$frame_in_second"
}

# Preview segment information and get confirmation
preview_segments() {
	logger "=== Media Configuration Preview ===" blue
	logger "${COLORS[green]}Configuration:${COLORS[reset]} $CONFIG_FILE"
	logger "${COLORS[green]}Output:${COLORS[reset]}        $OUTPUT_DIR/$FINAL_OUTPUT"
	logger ""

	# Display media specifications
	show_media_specs
	logger ""

	logger "=== Segment Structure Preview ===" blue

	# Table header with frame count column
	printf "%-15s %-20s %-12s %-12s %-12s %-25s\n" "SECTION_TYPE" "SECTION_NAME" "START_FRAME" "END_FRAME" "FRAME_COUNT" "TIMESTAMP"
	printf "%-15s %-20s %-12s %-12s %-12s %-25s\n" "============" "============" "===========" "=========" "===========" "======================="

	for segment_data in "${SEGMENTS[@]}"; do
		IFS=',' read -r type name start_frame end_frame <<< "$segment_data"

		local start_timecode
		start_timecode=$(frame_to_timecode "$start_frame")
		local end_timecode
		end_timecode=$(frame_to_timecode "$end_frame")

		# Calculate frame count for this segment
		local frame_count=$((end_frame - start_frame + 1))

		# Calculate duration for this segment
		local duration
		duration=$(calculate_duration "$start_frame" "$end_frame")
		# Format duration with decimal point alignment (supports up to 9999.999)
		local formatted_duration
		formatted_duration=$(printf "%7.3f" "$duration")

		printf "%-15s %-20s %-12s %-12s %-12s %-25s\n" "$type" "$name" "$start_frame" "$end_frame" "$frame_count" "$start_timecode - $end_timecode (${formatted_duration}s)"
	done

	logger ""

	if [[ "$SKIP_CONFIRMATION" == true ]]; then
		logger "Auto-confirmed with -y option. Starting generation..." green
		return 0
	fi

	logger "Start generation? (y/N): " yellow
	read -r response
	case "$response" in
		[yY]|[yY][eE][sS])
			logger "Starting generation..." green
			return 0
			;;
		*)
			logger "Generation cancelled by user" yellow
			exit 0
			;;
	esac
}

# Generate main program segment with enhanced logo for stable logo detection
generate_main_segment() {
	local segment_name=$1
	local duration=$2
	local output_file=$3

	ffmpeg -y -hide_banner \
		-f lavfi -i "pal75bars=size=1920x1080:rate=${CONFIG[FRAME_RATE]}:duration=$duration,crop=${CONFIG[VIDEO_WIDTH]}:${CONFIG[VIDEO_HEIGHT]}:'mod(24*t,1920-${CONFIG[VIDEO_WIDTH]})':0" \
		-f lavfi -i "anoisesrc=c=pink:r=${CONFIG[AUDIO_SAMPLE_RATE]}:d=$duration,equalizer=f=200:width_type=o:width=1:g=3,aformat=channel_layouts=stereo" \
		-filter_complex "
			[0:v]drawtext=fontfile='Ubuntu\:style=Bold':fontsize=60:fontcolor=white:text='$segment_name':x=(w-text_w)/2:y=(h-text_h)/2-80:box=1:boxcolor=black@0.8:boxborderw=10,
			drawtext=fontfile='Ubuntu\:style=Bold':fontsize=35:fontcolor=yellow:text='TIMECODE\: %{pts\:hms}':x=(w-text_w)/2:y=(h-text_h)/2+40:box=1:boxcolor=black@0.8:boxborderw=10,
			drawtext=fontfile='Ubuntu\:style=Bold':fontsize=40:fontcolor=white@0.35:text='JTV-Gen':x=w-text_w-40:y=40:box=0,
			setpts=PTS-STARTPTS,fps=${CONFIG[FRAME_RATE]},format=yuv420p[v];
			[1:a]volume=-14dB,alimiter=limit=-3dB:attack=5:release=50,asetpts=PTS-STARTPTS[a]
		" \
		-map "[v]" -map "[a]" \
		-c:v "${CONFIG[VIDEO_CODEC]}" -aspect 16:9 -profile:v main -level:v high \
		-pix_fmt yuv420p -colorspace bt709 -color_trc bt709 -color_primaries bt709 -color_range tv \
		-minrate "${CONFIG[VIDEO_BITRATE_MIN]}" -b:v "${CONFIG[VIDEO_BITRATE_AVG]}" -maxrate "${CONFIG[VIDEO_BITRATE_MAX]}" -bufsize 9781248 \
		-c:a "${CONFIG[AUDIO_CODEC]}" -profile:a "${CONFIG[AUDIO_PROFILE]}" \
		-b:a "${CONFIG[AUDIO_BITRATE]}" -ar "${CONFIG[AUDIO_SAMPLE_RATE]}" -ac "${CONFIG[AUDIO_CHANNELS]}" \
		-fflags +genpts \
		-avoid_negative_ts make_zero \
		-muxdelay 0 -muxpreload 0 \
		"$output_file" 2>> "$LOG_FILE"
}

# Generate CM segment with silence padding and color inversion
generate_cm_segment() {
	local segment_name=$1
	local duration=$2
	local output_file=$3
	local silence_dur=0.5
	local content_dur
	content_dur=$(echo "scale=6; $duration - 2 * $silence_dur" | bc -l)

	# Generate CM content (solid color with CM name)
	local cm_number
	cm_number=$(echo "$segment_name" | grep -o '[0-9]\+-[0-9]\+' | head -1)
	[[ -z "$cm_number" ]] && cm_number="1-1"  # fallback

	# Color selection for CM content
	local colors=("red" "blue" "green" "yellow" "magenta" "cyan")
	local color_hash
	color_hash=$(echo "$segment_name" | md5sum | head -c 2)
	local color_index=$(( (0x$color_hash) % ${#colors[@]}))
	local color="${colors[$color_index]}"

	# All CMs use the same structure: silence(inverted) -> content(normal) -> silence(inverted)
	ffmpeg -y -hide_banner \
		-f lavfi -i "color=$color:size=${CONFIG[VIDEO_WIDTH]}x${CONFIG[VIDEO_HEIGHT]}:rate=${CONFIG[FRAME_RATE]}:duration=$silence_dur" \
		-f lavfi -i "anullsrc=channel_layout=stereo:sample_rate=${CONFIG[AUDIO_SAMPLE_RATE]}:duration=$silence_dur" \
		-f lavfi -i "color=$color:size=${CONFIG[VIDEO_WIDTH]}x${CONFIG[VIDEO_HEIGHT]}:rate=${CONFIG[FRAME_RATE]}:duration=$content_dur" \
		-f lavfi -i "anoisesrc=c=white:r=${CONFIG[AUDIO_SAMPLE_RATE]}:d=$content_dur,equalizer=f=4000:width_type=o:width=1:g=2,aformat=channel_layouts=stereo" \
		-f lavfi -i "color=$color:size=${CONFIG[VIDEO_WIDTH]}x${CONFIG[VIDEO_HEIGHT]}:rate=${CONFIG[FRAME_RATE]}:duration=$silence_dur" \
		-f lavfi -i "anullsrc=channel_layout=stereo:sample_rate=${CONFIG[AUDIO_SAMPLE_RATE]}:duration=$silence_dur" \
		-filter_complex "
			[0:v]negate,drawtext=fontfile='Ubuntu\:style=Bold':fontsize=80:fontcolor=black:text='SILENCE':x=(w-text_w)/2:y=(h-text_h)/2[v_silence1];
			[1:a]volume=-70dB[a_silence1];
			[2:v]drawtext=fontfile='Ubuntu\:style=Bold':fontsize=100:fontcolor=white:text='CM $cm_number':x=(w-text_w)/2:y=(h-text_h)/2[v_content];
			[3:a]volume=-14dB,alimiter=limit=-3dB:attack=5:release=50[a_content];
			[4:v]negate,drawtext=fontfile='Ubuntu\:style=Bold':fontsize=80:fontcolor=black:text='SILENCE':x=(w-text_w)/2:y=(h-text_h)/2[v_silence2];
			[5:a]volume=-70dB[a_silence2];
			[v_silence1][a_silence1][v_content][a_content][v_silence2][a_silence2]concat=n=3:v=1:a=1[concatenated_v][concatenated_a];
			[concatenated_v]setpts=PTS-STARTPTS,fps=${CONFIG[FRAME_RATE]},format=yuv420p[v];
			[concatenated_a]asetpts=PTS-STARTPTS[a]
		" \
		-map "[v]" -map "[a]" \
		-c:v "${CONFIG[VIDEO_CODEC]}" -aspect 16:9 -profile:v main -level:v high \
		-pix_fmt yuv420p -colorspace bt709 -color_trc bt709 -color_primaries bt709 -color_range tv \
		-minrate "${CONFIG[VIDEO_BITRATE_MIN]}" -b:v "${CONFIG[VIDEO_BITRATE_AVG]}" -maxrate "${CONFIG[VIDEO_BITRATE_MAX]}" -bufsize 9781248 \
		-c:a "${CONFIG[AUDIO_CODEC]}" -profile:a "${CONFIG[AUDIO_PROFILE]}" \
		-b:a "${CONFIG[AUDIO_BITRATE]}" -ar "${CONFIG[AUDIO_SAMPLE_RATE]}" -ac "${CONFIG[AUDIO_CHANNELS]}" \
		-fflags +genpts \
		-avoid_negative_ts make_zero \
		-muxdelay 0 -muxpreload 0 \
		"$output_file" 2>> "$LOG_FILE"
}

# Calculate optimal number of parallel jobs
calculate_max_jobs() {
	local cpu_count
	cpu_count=$(nproc 2>/dev/null || echo "2")
	local max_jobs=$((cpu_count / 2))

	# Ensure at least 1 job
	if [[ $max_jobs -lt 1 ]]; then
		max_jobs=1
	fi

	# Cap at 4 jobs maximum
	if [[ $max_jobs -gt 4 ]]; then
		max_jobs=4
	fi

	echo "$max_jobs"
}

# Sort segments by frame count (descending order)
sort_segments_by_frames() {
	local sorted_segments=()

	# Create array with frame counts for sorting
	local segments_with_counts=()
	for segment_data in "${SEGMENTS[@]}"; do
		IFS=',' read -r type name start_frame end_frame <<< "$segment_data"
		[[ "$type" == "RecMargin" ]] && continue

		local frame_count=$((end_frame - start_frame + 1))
		segments_with_counts+=("$frame_count|$segment_data")
	done

	# Sort by frame count (descending)
	mapfile -t sorted_array < <(printf '%s\n' "${segments_with_counts[@]}" | sort -nr)

	# Extract sorted segments
	for entry in "${sorted_array[@]}"; do
		local segment_data="${entry#*|}"
		sorted_segments+=("$segment_data")
	done

	# Update SEGMENTS array
	SEGMENTS=("${sorted_segments[@]}")
}

# Process segment asynchronously in background
process_segment_async() {
	local segment_data=$1
	local segment_index=$2
	local total_segments=$3

	IFS=',' read -r type name start_frame end_frame <<< "$segment_data"

	local frame_duration=$((end_frame - start_frame + 1))
	local time_duration
	time_duration=$(calculate_duration "$start_frame" $((end_frame + 1)))
	local output_file
	output_file="$TEMP_DIR/segment_$(printf "%03d" "$segment_index")_${name}.ts"

	[[ "$DEBUG" == true ]] && logger "Background processing segment: $type,$name,$start_frame,$end_frame" yellow

	case "$type" in
		"Main")
			generate_main_segment "$name" "$time_duration" "$output_file" || {
				echo "ERROR:$name" > "$TEMP_DIR/error_$segment_index"
				exit 1
			}
			;;
		"CM")
			generate_cm_segment "$name" "$time_duration" "$output_file" || {
				echo "ERROR:$name" > "$TEMP_DIR/error_$segment_index"
				exit 1
			}
			;;
	esac

	# Mark completion
	echo "COMPLETED:$segment_index:$name:$frame_duration" > "$TEMP_DIR/completed_$segment_index"
}

# Update progress display when segment completes
update_progress() {
	local completed_count=$1
	local total_segments=$2
	local completed_name=$3

	local progress
	progress=$(echo "scale=2; $completed_count * 100 / $total_segments" | bc -l)

	logger "Overall: $(printf "%03d" "$completed_count")/$(printf "%03d" "$total_segments") ($(printf "%06.2f" "$progress")%)" green
	logger "Completed: $completed_name" green
}

# Generate all segments asynchronously
generate_segments() {
	logger "Generating individual segments" blue

	mkdir -p "$TEMP_DIR"

	# Get optimal number of parallel jobs
	local max_jobs
	max_jobs=$(calculate_max_jobs)
	logger "Using $max_jobs parallel jobs (CPU cores: $(nproc 2>/dev/null || echo "unknown"))" blue

	# Preserve original order BEFORE sorting
	local original_segments=("${SEGMENTS[@]}")
	declare -A original_order_map
	local original_index=0
	for segment_data in "${original_segments[@]}"; do
		IFS=',' read -r type name start_frame end_frame <<< "$segment_data"
		if [[ "$type" != "RecMargin" ]]; then
			original_order_map["$segment_data"]="$original_index"
		fi
		original_index=$((original_index + 1))
	done

	# Sort segments by frame count (heaviest first)
	sort_segments_by_frames

	# Count total segments (excluding RecMargin) and get original indices
	local total_segments=0
	local segment_list=()
	local original_indices=()
	for segment_data in "${SEGMENTS[@]}"; do
		IFS=',' read -r type name start_frame end_frame <<< "$segment_data"
		if [[ "$type" != "RecMargin" ]]; then
			segment_list+=("$segment_data")
			original_indices+=("${original_order_map["$segment_data"]}")
			total_segments=$((total_segments + 1))
		fi
	done

	logger "Processing $total_segments segments asynchronously" blue

	# Clean up any existing completion markers
	rm -f "$TEMP_DIR"/completed_* "$TEMP_DIR"/error_*

	local active_jobs=0
	local completed_jobs=0
	local segment_index=0
	local pids=()
	local segment_indices=()

	# Process segments
	for i in "${!segment_list[@]}"; do
		local segment_data="${segment_list[$i]}"
		local original_segment_index="${original_indices[$i]}"
		# Wait if we've reached max jobs
		while [[ $active_jobs -ge $max_jobs ]]; do
			# Check for completed jobs
			for j in "${!pids[@]}"; do
				local pid="${pids[$j]}"
				local seg_index="${segment_indices[$j]}"
				if ! kill -0 "$pid" 2>/dev/null; then
					# Job finished, remove from active list
					unset "pids[$j]"
					unset "segment_indices[$j]"
					active_jobs=$((active_jobs - 1))

					# Check for completion or error
					if [[ -f "$TEMP_DIR/completed_$seg_index" ]]; then
						local completion_info
						completion_info=$(cat "$TEMP_DIR/completed_$seg_index")
						IFS=':' read -r _ _ comp_name _ <<< "$completion_info"
						completed_jobs=$((completed_jobs + 1))
						update_progress "$completed_jobs" "$total_segments" "$comp_name"
					elif [[ -f "$TEMP_DIR/error_$seg_index" ]]; then
						local error_info
						error_info=$(cat "$TEMP_DIR/error_$seg_index")
						logger "Error in background job: $error_info" red
						# Kill remaining jobs
						for remaining_pid in "${pids[@]}"; do
							[[ -n "$remaining_pid" ]] && kill "$remaining_pid" 2>/dev/null
						done
						exit 1
					fi
				fi
			done

			# Clean up the pids array
			local temp_pids=()
			local temp_indices=()
			for k in "${!pids[@]}"; do
				if [[ -n "${pids[$k]}" ]]; then
					temp_pids+=("${pids[$k]}")
					temp_indices+=("${segment_indices[$k]}")
				fi
			done
			pids=("${temp_pids[@]}")
			segment_indices=("${temp_indices[@]}")

			# Short sleep to avoid busy waiting
			sleep 0.1
		done

		# Start new background job
		process_segment_async "$segment_data" "$original_segment_index" "$total_segments" &
		local bg_pid=$!
		pids+=("$bg_pid")
		segment_indices+=("$original_segment_index")
		active_jobs=$((active_jobs + 1))
		segment_index=$((segment_index + 1))

		[[ "$DEBUG" == true ]] && logger "Started background job $bg_pid for segment $segment_index" yellow
	done

	# Wait for all remaining jobs to complete
	logger "Waiting for remaining jobs to complete..." blue
	while [[ $completed_jobs -lt $total_segments ]]; do
		for m in "${!pids[@]}"; do
			local pid="${pids[$m]}"
			local seg_index="${segment_indices[$m]}"
			if [[ -n "$pid" ]] && ! kill -0 "$pid" 2>/dev/null; then
				# Job finished
				unset "pids[$m]"
				unset "segment_indices[$m]"
				active_jobs=$((active_jobs - 1))

				# Check for completion or error
				if [[ -f "$TEMP_DIR/completed_$seg_index" ]]; then
					local completion_info
					completion_info=$(cat "$TEMP_DIR/completed_$seg_index")
					IFS=':' read -r _ _ comp_name _ <<< "$completion_info"
					completed_jobs=$((completed_jobs + 1))
					update_progress "$completed_jobs" "$total_segments" "$comp_name"
				elif [[ -f "$TEMP_DIR/error_$seg_index" ]]; then
					local error_info
					error_info=$(cat "$TEMP_DIR/error_$seg_index")
					logger "Error in background job: $error_info" red
					# Kill remaining jobs
					for remaining_pid in "${pids[@]}"; do
						[[ -n "$remaining_pid" ]] && kill "$remaining_pid" 2>/dev/null
					done
					exit 1
				fi
			fi
		done

		# Clean up the pids array
		local temp_pids=()
		local temp_indices=()
		for i in "${!pids[@]}"; do
			if [[ -n "${pids[$i]}" ]]; then
				temp_pids+=("${pids[$i]}")
				temp_indices+=("${segment_indices[$i]}")
			fi
		done
		pids=("${temp_pids[@]}")
		segment_indices=("${temp_indices[@]}")

		sleep 0.1
	done

	logger "All $total_segments segments generated successfully" green

	# Clean up completion markers
	rm -f "$TEMP_DIR"/completed_* "$TEMP_DIR"/error_*
}

# Concatenate all segments
concatenate_segments() {
	logger "Concatenating segments to intermediate output" blue

	# Create concat list
	local concat_file="$TEMP_DIR/concat_list.txt"
	: > "$concat_file"

	# Sort segment files by their numeric index to maintain config order
	local files_found=0
	for i in $(seq -f "%03g" 0 999); do
		# Use array to properly handle glob expansion
		local segment_files=("$TEMP_DIR/segment_${i}_"*.ts)

		# Check if any files match the pattern (avoid unmatched glob expansion)
		if [[ -f "${segment_files[0]}" ]]; then
			for matched_file in "${segment_files[@]}"; do
				if [[ -f "$matched_file" ]]; then
					echo "file '$(realpath "$matched_file")'" >> "$concat_file"
					files_found=$((files_found + 1))
					[[ "$DEBUG" == true ]] && logger "Added to concat: $(basename "$matched_file")" blue
				fi
			done
		fi
	done

	logger "Found $files_found segment files to concatenate" blue

	# Verify concat file has content
	if [[ ! -s "$concat_file" ]]; then
		logger "Error: No segment files found for concatenation" red
		logger "Expected files: $TEMP_DIR/segment_*_*.ts" red
		return 1
	fi

	# Concatenate using stream copy (no re-encoding)
	ffmpeg -y -hide_banner \
		-fflags +genpts+igndts \
		-avoid_negative_ts make_zero \
		-f concat -safe 0 -i "$concat_file" \
		-c:v copy -c:a copy \
		-mpegts_service_id "${CONFIG[BROADCAST_SERVICE_ID]}" \
		-mpegts_transport_stream_id "${CONFIG[BROADCAST_TRANSPORT_STREAM_ID]}" \
		-mpegts_start_pid 273 \
		-mpegts_pmt_start_pid 257 \
		-metadata service_provider="${CONFIG[BROADCAST_SERVICE_PROVIDER]}" \
		-metadata service_name="${CONFIG[BROADCAST_SERVICE_NAME]}" \
		-f mpegts \
		"$TEMP_DIR/$FINAL_OUTPUT" 2>> "$LOG_FILE"

	local ffmpeg_result=$?
	if [[ $ffmpeg_result -eq 0 ]]; then
		logger "Intermediate output created: $TEMP_DIR/$FINAL_OUTPUT" green
	else
		logger "Error: Failed to concatenate segments (exit code: $ffmpeg_result)" red
		return 1
	fi
}

# Generate optimized broadcast metadata files
generate_metadata_files() {
	logger "Generating comprehensive PSI/SI tables" blue

	mkdir -p "$OUTPUT_DIR"
	mkdir -p "$TEMP_DIR"

	# Calculate duration for EIT
	local duration_hms
	duration_hms=$(printf "%02d:%02d:%02d" $((${CONFIG[BROADCAST_DURATION_SECONDS]%.*}/3600)) $(((${CONFIG[BROADCAST_DURATION_SECONDS]%.*}%3600)/60)) $((${CONFIG[BROADCAST_DURATION_SECONDS]%.*}%60)))

	# PAT - Program Association Table
	local pat_file="$TEMP_DIR/pat.xml"
	cat > "$pat_file" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<tsduck>
  <PAT version="3" current="true" transport_stream_id="${CONFIG[BROADCAST_TRANSPORT_STREAM_ID]}" network_PID="16">
	<service service_id="${CONFIG[BROADCAST_SERVICE_ID]}" program_map_PID="257"/>
  </PAT>
</tsduck>
EOF

	# NIT - Network Information Table
	local nit_file="$TEMP_DIR/nit.xml"
	cat > "$nit_file" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<tsduck>
  <NIT version="1" current="true" actual="true" network_id="${CONFIG[BROADCAST_ORIGINAL_NETWORK_ID]}">
	<network_name_descriptor network_name="${CONFIG[BROADCAST_NETWORK_NAME]}"/>
	<transport_stream transport_stream_id="${CONFIG[BROADCAST_TRANSPORT_STREAM_ID]}"
					  original_network_id="${CONFIG[BROADCAST_ORIGINAL_NETWORK_ID]}">
	  <service_list_descriptor>
		<service service_id="${CONFIG[BROADCAST_SERVICE_ID]}" service_type="1"/>
	  </service_list_descriptor>
	</transport_stream>
  </NIT>
</tsduck>
EOF

	# SDT - Service Description Table
	local sdt_file="$TEMP_DIR/sdt.xml"
	cat > "$sdt_file" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<tsduck>
  <SDT version="1" current="true" actual="true"
	   transport_stream_id="${CONFIG[BROADCAST_TRANSPORT_STREAM_ID]}"
	   original_network_id="${CONFIG[BROADCAST_ORIGINAL_NETWORK_ID]}">
	<service service_id="${CONFIG[BROADCAST_SERVICE_ID]}"
			 EIT_schedule="false"
			 EIT_present_following="true"
			 running_status="running"
			 CA_mode="false">
	  <service_descriptor
		  service_type="1"
		  service_provider_name="${CONFIG[BROADCAST_SERVICE_PROVIDER]}"
		  service_name="${CONFIG[BROADCAST_SERVICE_NAME]}"/>
	</service>
  </SDT>
</tsduck>
EOF

	# EIT - Event Information Table (PF: Present/Following)
	local eit_file="$TEMP_DIR/eit.xml"
	cat > "$eit_file" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<tsduck>
  <EIT version="1" current="true" actual="true"
	   service_id="${CONFIG[BROADCAST_SERVICE_ID]}"
	   transport_stream_id="${CONFIG[BROADCAST_TRANSPORT_STREAM_ID]}"
	   original_network_id="${CONFIG[BROADCAST_ORIGINAL_NETWORK_ID]}"
	   last_table_id="78"
	   type="pf">
	<event event_id="1001"
		   start_time="${CONFIG[BROADCAST_START_TIME]}"
		   duration="${duration_hms}"
		   running_status="running"
		   CA_mode="false">
	  <short_event_descriptor language_code="jpn">
		<event_name>${CONFIG[BROADCAST_SERVICE_NAME]} Program</event_name>
		<text>ARIB compliant test stream</text>
	  </short_event_descriptor>
	  <component_descriptor stream_content="1" stream_content_ext="15" component_type="3" component_tag="0" language_code="jpn" text=""/>
	  <content_descriptor>
		<content content_nibble_level_1="0" content_nibble_level_2="0" user_byte="0"/>
		<content content_nibble_level_1="1" content_nibble_level_2="0" user_byte="0"/>
	  </content_descriptor>
	</event>
  </EIT>
</tsduck>
EOF

	# TOT - Time Offset Table
	local tot_file="$TEMP_DIR/tot.xml"
	cat > "$tot_file" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<tsduck>
  <TOT UTC_time="${CONFIG[BROADCAST_START_TIME]}">
	<local_time_offset_descriptor>
	  <region country_code="JPN"
			  country_region_id="0"
			  local_time_offset="540"
			  time_of_change="2000-01-01 00:00:00"
			  next_time_offset="540"/>
	</local_time_offset_descriptor>
  </TOT>
</tsduck>
EOF

	# PMT - Program Map Table
	local pmt_file="$TEMP_DIR/pmt.xml"
	cat > "$pmt_file" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<tsduck>
  <PMT version="12" current="true" service_id="${CONFIG[BROADCAST_SERVICE_ID]}" PCR_PID="273">
	<component elementary_PID="273" stream_type="0x02">
	  <stream_identifier_descriptor component_tag="0"/>
	</component>
	<component elementary_PID="274" stream_type="0x0F">
	  <stream_identifier_descriptor component_tag="16"/>
	</component>
  </PMT>
</tsduck>
EOF

	logger "Generated comprehensive PSI/SI tables:" green
	logger "${COLORS[green]}  PAT:${COLORS[reset]}         temp/pat.xml (Program Association Table)"
	logger "${COLORS[green]}  NIT:${COLORS[reset]}         temp/nit.xml (Network Information Table)"
	logger "${COLORS[green]}  SDT:${COLORS[reset]}         temp/sdt.xml (Service Description Table)"
	logger "${COLORS[green]}  EIT:${COLORS[reset]}         temp/eit.xml (Event Information Table)"
	logger "${COLORS[green]}  TOT:${COLORS[reset]}         temp/tot.xml (Time Offset Table)"
	logger "${COLORS[green]}  PMT:${COLORS[reset]}         temp/pmt.xml (Program Map Table)"
}

# Inject comprehensive PSI/SI metadata
inject_eit_metadata() {
	logger "Injecting comprehensive PSI/SI metadata" blue

	local input_file="$TEMP_DIR/$FINAL_OUTPUT"
	local tables_dir="$TEMP_DIR"
	local output_file="$TEMP_DIR/${FINAL_OUTPUT%.ts}_with_metadata.ts"

	# Input file check
	if [[ ! -f "$input_file" ]]; then
		logger "Error: Input file $input_file not found" red
		return 1
	fi

	# Compile XML tables to binary
	logger "Compiling PSI/SI tables" yellow
	local required_tables=("pat" "pmt" "nit" "sdt" "eit" "tot")
	for table in "${required_tables[@]}"; do
		if [[ -f "$tables_dir/${table}.xml" ]]; then
			logger "Compiling ${table}.xml" blue
			if ! tstabcomp --japan "$tables_dir/${table}.xml" -o "$tables_dir/${table}.bin" 2>> "$LOG_FILE"; then
				logger "Error: Failed to compile ${table}.xml" red
				logger "Check log file: $LOG_FILE" red
				return 1
			else
				logger "✓ ${table}.bin compiled successfully" green
			fi
		else
			logger "Warning: ${table}.xml not found, skipping" yellow
		fi
	done

	# Optimized injection using single tsp pipeline
	logger "Injecting PSI/SI tables" yellow

	# Check which tables are available (comprehensive PSI/SI)
	local available_tables=()
	for table in pat pmt nit sdt eit tot; do
		if [[ -f "$tables_dir/${table}.bin" ]]; then
			available_tables+=("$table")
			logger "✓ ${table}.bin ready for injection" green
		else
			logger "⚠ ${table}.bin not available" yellow
		fi
	done

	if [[ ${#available_tables[@]} -eq 0 ]]; then
		logger "Error: No PSI/SI tables available for injection" red
		return 1
	fi

	logger "Starting injection with ${#available_tables[@]} tables" blue
	# Comprehensive PSI/SI injection
	logger "Using comprehensive PSI/SI injection" blue
	local tsp_cmd="tsp --japan --add-input-stuffing 1/25 -I file \"$input_file\""

	# PAT injection (PID 0)
	if [[ -f "$tables_dir/pat.bin" ]]; then
		tsp_cmd="$tsp_cmd -P inject \"$tables_dir/pat.bin\" --pid 0 --replace"
	fi

	# NIT injection (PID 16)
	if [[ -f "$tables_dir/nit.bin" ]]; then
		tsp_cmd="$tsp_cmd -P inject \"$tables_dir/nit.bin\" --pid 16 --inter-packet $((  1000/4 ))"
	fi

	# SDT injection (PID 17)
	if [[ -f "$tables_dir/sdt.bin" ]]; then
		tsp_cmd="$tsp_cmd -P inject \"$tables_dir/sdt.bin\" --pid 17 --replace"
	fi

	# EIT injection (PID 18)
	if [[ -f "$tables_dir/eit.bin" ]]; then
		tsp_cmd="$tsp_cmd -P inject \"$tables_dir/eit.bin\" --pid 18 --inter-packet $((  1000/4 ))"
	fi

	# TOT injection (PID 20)
	if [[ -f "$tables_dir/tot.bin" ]]; then
		tsp_cmd="$tsp_cmd -P inject \"$tables_dir/tot.bin\" --pid 20 --inter-packet $(( 10000/4 ))"
	fi

	# PMT injection (PID 257)
	if [[ -f "$tables_dir/pmt.bin" ]]; then
		tsp_cmd="$tsp_cmd -P inject \"$tables_dir/pmt.bin\" --pid 257 --replace"
	fi

	tsp_cmd="$tsp_cmd -P continuity --fix -O file \"$output_file\""

	logger "Executing: $tsp_cmd" blue
	eval "$tsp_cmd" 2>&1 | tee -a "$LOG_FILE"
	local injection_result=${PIPESTATUS[0]}

	if [[ $injection_result -ne 0 ]]; then
		logger "Error: TSDuck injection failed with exit code $injection_result" red
		return 1
	fi

	# Result verification
	if [[ -f "$output_file" ]] && [[ -s "$output_file" ]]; then
		cp -v "$output_file" "$input_file"
		logger "Optimized PSI/SI metadata injection completed successfully" green

		# Enhanced verification with detailed output
		if command -v tsanalyze >/dev/null 2>&1; then
			logger "Analyzing injected tables:" blue
			local verification_output
			verification_output=$(tsanalyze "$input_file" 2>/dev/null | grep -E "(EIT|SDT|TOT)" || true)
			if [[ -n "$verification_output" ]]; then
				echo "$verification_output"
				if echo "$verification_output" | grep -q "EIT"; then
					logger "✓ EIT table detected - event information should be available" green
				else
					logger "⚠ EIT table not detected in analysis" yellow
				fi
				if echo "$verification_output" | grep -q "TOT"; then
					logger "✓ TOT table detected - time information should be available" green
				else
					logger "⚠ TOT table not detected in analysis" yellow
				fi
			else
				logger "⚠ No PSI/SI tables detected in analysis" yellow
			fi
		fi

		return 0
	else
		logger "Error: PSI/SI metadata injection failed" red
		return 1
	fi
}

# Verify broadcast compatibility
verify_broadcast_compatibility() {
	local output_file="$1"

	logger "Verifying broadcast compatibility" blue

	if [[ ! -f "$output_file" ]]; then
		logger "Error: Output file not found for verification" red
		return 1
	fi

	# PSI/SI structure verification
	logger "PSI/SI structure verification:" yellow
	if command -v tsanalyze >/dev/null 2>&1; then
		local structure_check
		structure_check=$(tsanalyze "$output_file" --japan --normalized 2>/dev/null | grep -E "pid:pid=(17|20):" | head -5 || true)
		if [[ -n "$structure_check" ]]; then
			echo "$structure_check"
		else
			logger "  Structure analysis: No PSI/SI tables detected" yellow
		fi
	else
		logger "Warning: tsanalyze not available, skipping structure check" yellow
	fi

	# Detailed broadcast compatibility checks
	logger "Broadcast compatibility checks:" yellow

	# 1. Service information verification
	logger "1. Service information:" blue
	if command -v tsp >/dev/null 2>&1; then
		local service_info
		service_info=$(tsp -I file "$output_file" -P tables --pid 17 --max 1 --text-output - -O drop 2>/dev/null | \
			grep -E "(Service|service_name)" | head -3 || true)
		if [[ -n "$service_info" ]]; then
			echo "$service_info"
		else
			logger "  Service info: Not detected" yellow
		fi
	fi

	# 2. Time information verification
	logger "2. Time information:" blue
	if command -v tsp >/dev/null 2>&1; then
		local time_info
		time_info=$(tsp -I file "$output_file" -P tables --pid 20 --max 1 --text-output - -O drop 2>/dev/null | \
			grep -E "(TOT|UTC_time)" | head -2 || true)
		if [[ -n "$time_info" ]]; then
			echo "$time_info"
		else
			logger "  Time info: Not detected" yellow
		fi
	fi

	# 3. Event information verification
	logger "3. Event information:" blue
	if command -v tsp >/dev/null 2>&1; then
		local event_info
		event_info=$(tsp -I file "$output_file" -P tables --pid 18 --max 1 --text-output - -O drop 2>/dev/null | \
			grep -E "(Event|event_name)" | head -3 || true)
		if [[ -n "$event_info" ]]; then
			echo "$event_info"
		else
			logger "  Event info: Not detected" yellow
		fi
	fi

	# Broadcast verification procedure
	logger "Broadcast verification procedure:" green
	logger "  1. Check PSI/SI metadata injection" green
	logger "  2. Verify service information display" green
	logger "  3. Confirm the following are included:" green
	logger "     ✅ Genre information" green
	logger "     ✅ Resolution information" green
	logger "     ✅ Service name: ${CONFIG[BROADCAST_SERVICE_NAME]}" green
	logger "     ✅ Start time: ${CONFIG[BROADCAST_START_TIME]}" green

	return 0
}

# Move final output from temp to output directory
move_final_output() {
	logger "Moving final output to destination" blue

	mkdir -p "$OUTPUT_DIR"

	local temp_file="$TEMP_DIR/$FINAL_OUTPUT"
	local output_file="$OUTPUT_DIR/$FINAL_OUTPUT"

	if [[ ! -f "$temp_file" ]]; then
		logger "Error: Final output file $temp_file not found" red
		return 1
	fi

	# Move the final file to output directory
	mv "$temp_file" "$output_file"

	if [[ -f "$output_file" ]]; then
		local file_size
		file_size=$(stat -c%s "$output_file" 2>/dev/null | numfmt --to=iec || echo "unknown")
		logger "Final output ready: $output_file(with EIT metadata) ($file_size)" green
		return 0
	else
		logger "Error: Failed to move final output" red
		return 1
	fi
}

# Generate report
generate_report() {
	logger "Generating report" blue

	local report_file="$OUTPUT_DIR/generation_report.txt"
	local csv_file="$OUTPUT_DIR/segment_structure.csv"

	{
		echo "Japanese TV Content Generator Report"
		echo "=========================="
		echo "Generated: $(date)"
		echo "Configuration: $CONFIG_FILE"
		echo "Output: $OUTPUT_DIR/$FINAL_OUTPUT (with EIT metadata)"
		echo ""
		echo "Technical Specifications:"
		echo "- Video:             ${CONFIG[VIDEO_WIDTH]}x${CONFIG[VIDEO_HEIGHT]} 16:9 ${CONFIG[FRAME_RATE]}fps"
		echo "- Video Codec:       ${CONFIG[VIDEO_CODEC]} avg ${CONFIG[VIDEO_BITRATE_AVG]}"
		echo "- Audio:             ${CONFIG[AUDIO_SAMPLE_RATE]}Hz ${CONFIG[AUDIO_CHANNELS]}ch ${CONFIG[AUDIO_BITRATE]}"
		echo "- Audio Levels:      0VU=-14dBFS, Silence<-70dBFS"
		echo ""
		echo "Broadcast Metadata:"
		echo "- Service ID:        ${CONFIG[BROADCAST_SERVICE_ID]}"
		echo "- Transport Stream:  ${CONFIG[BROADCAST_TRANSPORT_STREAM_ID]}"
		echo "- Original Network:  ${CONFIG[BROADCAST_ORIGINAL_NETWORK_ID]}"
		echo "- Service Name:      \"${CONFIG[BROADCAST_SERVICE_NAME]}\""
		echo "- Service Provider:  \"${CONFIG[BROADCAST_SERVICE_PROVIDER]}\""
		echo "- Network Name:      \"${CONFIG[BROADCAST_NETWORK_NAME]}\""
		echo "- EIT Start Time:    ${CONFIG[BROADCAST_START_TIME]}"
		echo "- EIT Status:        Present/Following enabled"
		echo ""
		echo "EIT/SDT/TOT Metadata Files:"
		if [[ -f "$TEMP_DIR/eit.xml" ]]; then
			echo "- EIT (Event Information Table):     Generated"
			echo "  File: $TEMP_DIR/eit.xml"
			echo "  Status: Injected into final output"
		else
			echo "- EIT (Event Information Table):     Not generated"
		fi
		if [[ -f "$TEMP_DIR/sdt.xml" ]]; then
			echo "- SDT (Service Description Table):   Generated"
			echo "  File: $TEMP_DIR/sdt.xml"
			echo "  Status: Injected into final output"
		else
			echo "- SDT (Service Description Table):   Not generated"
		fi
		if [[ -f "$TEMP_DIR/tot.xml" ]]; then
			echo "- TOT (Time Offset Table):           Generated"
			echo "  File: $TEMP_DIR/tot.xml"
			echo "  Status: Injected into final output"
		else
			echo "- TOT (Time Offset Table):           Not generated"
		fi
		echo ""
		echo "Segment Structure:"
		local segment_count=0
		for segment_data in "${SEGMENTS[@]}"; do
			IFS=',' read -r type name start_frame end_frame <<< "$segment_data"
			[[ "$type" == "RecMargin" ]] && continue
			local frame_duration=$((end_frame - start_frame + 1))
			local time_duration
			time_duration=$(calculate_duration "$start_frame" $((end_frame + 1)))
			printf "  %2d. %-12s: %5d frames (%7.3fs)\n" $((++segment_count)) "$name" "$frame_duration" "$time_duration"
		done
	} > "$report_file"

	# CSV for external processing
	echo "Segment,Type,StartFrame,EndFrame,Duration_Frames,Duration_Seconds" > "$csv_file"
	segment_count=0
	for segment_data in "${SEGMENTS[@]}"; do
		IFS=',' read -r type name start_frame end_frame <<< "$segment_data"
		[[ "$type" == "RecMargin" ]] && continue
		local frame_duration=$((end_frame - start_frame + 1))
		local time_duration
		time_duration=$(calculate_duration "$start_frame" $((end_frame + 1)))
		echo "$name,$type,$start_frame,$end_frame,$frame_duration,$time_duration" >> "$csv_file"
		segment_count=$((segment_count + 1))
	done

	logger "Report generated: $report_file" green
	logger "CSV structure: $csv_file" green
}

# Cleanup temporary files
cleanup() {
	if [[ "$DEBUG" == true ]] || [[ "${1:-}" == "keep" ]]; then
		logger "Keeping temporary files in $TEMP_DIR (debug mode)" yellow
	else
		logger "Cleaning up temporary files" blue
		rm -rf "$TEMP_DIR"
	fi
}

# Check system dependencies and ffmpeg capabilities
check_dependencies() {
	logger "Checking system dependencies and capabilities" blue

	local missing_deps=()
	local ffmpeg_issues=()

	# Check basic commands
	local required_commands=("awk" "bc" "ffmpeg" "ffprobe" "grep" "jq" "md5sum")
	for cmd in "${required_commands[@]}"; do
		if ! command -v "$cmd" >/dev/null 2>&1; then
			missing_deps+=("$cmd")
		fi
	done

	# Check TSDuck if EIT injection is enabled (default)
	if ! command -v "tsp" >/dev/null 2>&1; then
		logger "Error: TSDuck is required but not found." red
		show_tsduck_install_instructions
		exit 1
	else
		# Check TSDuck version (require 3.41+)
		local tsduck_version
		tsduck_version=$(tsp --version 2>&1 | head -1 | grep -o '[0-9]\+\.[0-9]\+' | head -1)
		if [[ -n "$tsduck_version" ]]; then
			local version_check
			version_check=$(echo "$tsduck_version >= 3.41" | bc 2>/dev/null)
			if [[ "$version_check" != "1" ]]; then
				logger "Error: TSDuck version $tsduck_version is too old. Version 3.41 or higher is required." red
				show_tsduck_install_instructions
				exit 1
			fi
		else
			logger "Warning: Could not determine TSDuck version. Proceeding anyway..." yellow
		fi
	fi

	if [[ ${#missing_deps[@]} -gt 0 ]]; then
		logger "Error: Missing required commands: ${missing_deps[*]}" red
		logger "Please install the missing dependencies:" yellow
		for dep in "${missing_deps[@]}"; do
			case "$dep" in
				"bc")				logger "  - bc: sudo apt-get install bc (Ubuntu/Debian)" ;;
				"ffmpeg"|"ffprobe")	logger "  - FFmpeg: https://ffmpeg.org/download.html" ;;
				"jq")				logger "  - jq: sudo apt-get install jq (Ubuntu/Debian)" ;;
				"tsp (TSDuck)")		logger "  - TSDuck: https://tsduck.io/download/tsduck/" ;;
				*)					logger "  - $dep: available in most standard Unix environments" ;;
			esac
		done
		exit 1
	fi

	# Check FFmpeg capabilities
	logger "Verifying FFmpeg codec and filter support" blue

	# Basic FFmpeg functionality test
	if ! ffmpeg -f lavfi -i "testsrc=size=320x240:duration=1" -t 1 -f null - 2>/dev/null; then
		ffmpeg_issues+=("FFmpeg basic video generation not working")
	fi


	# Essential capabilities check
	local warnings=()

	# Test MPEG-2 video codec
	local mpeg2_check
	mpeg2_check=$(ffmpeg -hide_banner -codecs 2>&1 | grep -i "mpeg2video" || true)
	if [[ -z "$mpeg2_check" ]]; then
		warnings+=("MPEG-2 video codec")
	fi

	# Test AAC audio codec
	local aac_check
	aac_check=$(ffmpeg -hide_banner -codecs 2>&1 | grep -i "aac" || true)
	if [[ -z "$aac_check" ]]; then
		warnings+=("AAC audio codec")
	fi

	# Test drawtext filter
	local drawtext_check
	drawtext_check=$(ffmpeg -hide_banner -filters 2>&1 | grep -i "drawtext" || true)
	if [[ -z "$drawtext_check" ]]; then
		warnings+=("drawtext filter for text overlay")
	fi

	# Test MPEG-TS muxer
	local mpegts_check
	mpegts_check=$(ffmpeg -hide_banner -muxers 2>&1 | grep -i "mpegts" || true)
	if [[ -z "$mpegts_check" ]]; then
		warnings+=("MPEG-TS muxer")
	fi

	# Check Ubuntu font for optimal text rendering
	# Use dpkg only - it's more reliable than fc-list which can be unstable after interruption
	local font_check
	font_check=$(dpkg -l 2>/dev/null | grep -i "fonts-ubuntu" || true)
	if [[ -z "$font_check" ]]; then
		warnings+=("Ubuntu font (install with: sudo apt install fonts-ubuntu)")
	fi

	if [[ ${#warnings[@]} -gt 0 ]]; then
		logger "Error: Critical dependencies missing:" red
		for warning in "${warnings[@]}"; do
			logger "  - $warning" red
		done
		logger "Please install missing dependencies before running the script." red
		exit 1
	fi

	if [[ ${#ffmpeg_issues[@]} -gt 0 ]]; then
		logger "Error: FFmpeg configuration issues detected:" red
		for issue in "${ffmpeg_issues[@]}"; do
			logger "  - $issue" red
		done
		logger "Please install a complete FFmpeg build with all required codecs and filters." yellow
		logger "Recommended: Use official FFmpeg builds or install via package manager." yellow
		exit 1
	fi

	# Display FFmpeg version info
	local ffmpeg_version
	ffmpeg_version=$(ffmpeg -version 2>/dev/null | head -1 | cut -d' ' -f3)
	logger "✓ All dependencies available" green
	logger "✓ FFmpeg version: $ffmpeg_version" green
	logger "✓ TSDuck version: $tsduck_version" green
	logger "✓ All required codecs and filters available" green
}

# Main execution
main() {
	logger "=== JTV Gen Started ===" green
	logger "Timestamp: $(date)"

	# Check dependencies first
	check_dependencies

	# Initialize log
	: > "$LOG_FILE"

	# Process
	load_config

	# Pre-generate directories
	logger "Preparing temporary directories" blue
	mkdir -p "$TEMP_DIR"
	touch "$TEMP_DIR/_${CONFIG_BASENAME}_$(date '+%Y%m%dT%H%M%S')"
	# Logo generation no longer needed - using direct drawtext rendering

	generate_metadata_files
	preview_segments
	generate_segments
	concatenate_segments
	inject_eit_metadata
	move_final_output
	generate_report

	# Enhanced verification with broadcast compatibility check
	local final_output_path="$OUTPUT_DIR/$FINAL_OUTPUT"
	if [[ -f "$final_output_path" ]]; then
		logger "Technical verification:" blue
		ffprobe -v quiet -print_format json -show_format "$final_output_path" 2>/dev/null | \
			jq -r '.format | "Duration: \(.duration)s, Size: \(.size) bytes, Bitrate: \(.bit_rate) bps"' 2>/dev/null || \
			ffprobe -v error -show_entries format=duration,size,bit_rate -of csv=p=0 "$final_output_path"

		# Run broadcast compatibility verification
		verify_broadcast_compatibility "$final_output_path"
	fi

	cleanup "${1:-}"
	logger "=== JTV Gen Completed ===" green
}

# Script execution
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
	main "$@"
fi
